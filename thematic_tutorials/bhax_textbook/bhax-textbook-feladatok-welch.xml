<chapter xmlns="http://docbook.org/ns/docbook" xmlns:xlink="http://www.w3.org/1999/xlink" xmlns:xi="http://www.w3.org/2001/XInclude" version="5.0" xml:lang="hu">
    <info>
        <title>Helló, Welch!</title>
        <keywordset>
            <keyword/>
        </keywordset>
    </info>
    <section>
        <title>I. Első osztályom</title>
        <para>
            Valósítsd meg C++-ban és Java-ban az módosított polártranszformációs algoritmust! A matek háttér 
            teljesen irreleváns, csak annyiban érdekes, hogy az algoritmus egy számítása során két normálist
            számol ki, az egyiket elspájzolod és egy további logikai taggal az osztályban jelzed, hogy van vagy
            nincs eltéve kiszámolt szám.
        </para>
        <para>
            Megoldás forrása:                
        </para>
        <programlisting><![CDATA[
            public class PolarGenerator {
            boolean nincsTarolt = true;
            double tarolt;
            public PolarGenerator() {

                nincsTarolt = true;

            }
            public double kovetkezo() {
                if(nincsTarolt) {
                    double u1, u2, v1, v2, w;
                    do {
                        u1 = Math.random();
                        u2 = Math.random();

                        v1 = 2*u1 - 1;
                        v2 = 2*u2 - 1;

                        w = v1*v1 + v2*v2;

                    } while(w > 1);

                    double r = Math.sqrt((-2*Math.log(w))/w);

                    tarolt = r*v2;
                    nincsTarolt = !nincsTarolt;

                    return r*v1;

                } else {
            
                    nincsTarolt = !nincsTarolt;
                    return tarolt;
                }
            }

            public static void main(String[] args) {
            
                PolarGenerator g = new PolarGenerator();
                for(int i=0; i<10; ++i)
                    System.out.println(g.kovetkezo());
            }
        }
        ]]></programlisting>
        <para>
           <emphasis role = "strong">Tanulságok, tapasztalatok, magyarázat:</emphasis>
        </para>
        <para>
            A módosított polártranszformációs generátor argumentum két
            véletlenszerű érték generálása alkalmazható.
        </para>
		<screen>
            <![CDATA[$ /java/bin/java polargen.java
            -0.7353431820414118
            -0.33784190028284766
            0.7750031835316805
            0.5524713543467192
            -0.5380423283211784
            1.512849268596637
            2.7148874695500966
            -0.23688836801277952
            -0.3238588036816322
            -0.7963150809415576
            
            
            $ /java/bin/java polargen.java
            -0.6566325405553158
            0.40465899229436114
            0.08634239512228409
            -0.9470321445590416
            0.1926238606249351
            0.7705517022243931
            0.9084531239664848
            -1.4472688950554047
            -1.6250659297425345
            -0.7791586500972545]]>
                            </screen>
            <para>
                A program 10 darab véletlenszerűen generált normalizált számot ad ki. A OO előnyét itt 
                látjuk, hiszen a matematikai háttér részünkre nem fontos, és ezt az osztály el is rejti 
                előlünk. A programunk mégis működik.
            </para>               
    </section>        

    <section>
        <title>II. LZW</title>
        <para>
            Valósítsd meg C-ben az LZW algoritmus fa-építését!
        </para>
        <para>
            Megoldás forrása:                
        </para>
        <programlisting><![CDATA[
            // z3a7.cpp
            #include <iostream>		// mert olvassuk a std::cin, írjuk a std::cout csatornákat
            #include <cmath>		// mert vonunk gyököt a szóráshoz: std::sqrt
            #include <fstream>		// fájlból olvasunk, írunk majd

            class LZWBinFa
            {
            public:
                LZWBinFa ():fa (&gyoker)
                {
                }
                ~LZWBinFa ()
                {
                    szabadit (gyoker.egyesGyermek ());
                    szabadit (gyoker.nullasGyermek ());
                }
                void operator<< (char b)
                {
                    if (b == '0')
                    {
                        if (!fa->nullasGyermek ())
                        {
                            Csomopont *uj = new Csomopont ('0');
                            fa->ujNullasGyermek (uj);
                            fa = &gyoker;
                        }
                        else
                        {
                            fa = fa->nullasGyermek ();
                        }
                    }
                    // Mit kell betenni éppen, vagy '1'-et?
                    else
                    {
                        if (!fa->egyesGyermek ())
                        {
                            Csomopont *uj = new Csomopont ('1');
                            fa->ujEgyesGyermek (uj);
                            fa = &gyoker;
                        }
                        else
                        {
                            fa = fa->egyesGyermek ();
                        }
                    }
                }
                void kiir (void)
                {
                    melyseg = 0;
                    kiir (&gyoker, std::cout);
                }
                int getMelyseg (void);
                double getAtlag (void);
                double getSzoras (void);

                friend std::ostream & operator<< (std::ostream & os, LZWBinFa & bf)
                {
                    bf.kiir (os);
                    return os;
                }
                void kiir (std::ostream & os)
                {
                    melyseg = 0;
                    kiir (&gyoker, os);
                }
            private:
                class Csomopont
                {
                public:
                    Csomopont (char b = '/'):betu (b), balNulla (0), jobbEgy (0)
                    {
                    };
                    ~Csomopont ()
                    {
                    };
                    Csomopont *nullasGyermek () const
                    {
                        return balNulla;
                    }
                    Csomopont *egyesGyermek () const
                    {
                        return jobbEgy;
                    }
                    void ujNullasGyermek (Csomopont * gy)
                    {
                        balNulla = gy;
                    }
                    void ujEgyesGyermek (Csomopont * gy)
                    {
                        jobbEgy = gy;
                    }
                    char getBetu () const
                    {
                        return betu;
                    }
                private:
                    char betu;
                    Csomopont *balNulla;
                    Csomopont *jobbEgy;
                    Csomopont (const Csomopont &); //másoló konstruktor
                    Csomopont & operator= (const Csomopont &);
                };
                Csomopont *fa;
                int melyseg, atlagosszeg, atlagdb;
                double szorasosszeg;
                    //nocopy
                    LZWBinFa (const LZWBinFa &);
                LZWBinFa & operator= (const LZWBinFa &);

                void kiir (Csomopont * elem, std::ostream & os)
                {
                    if (elem != NULL)
                    {
                        ++melyseg;
                        kiir (elem->egyesGyermek (), os);
                        for (int i = 0; i < melyseg; ++i)
                            os << "---";
                        os << elem->getBetu () << "(" << melyseg - 1 << ")" << std::endl;
                        kiir (elem->nullasGyermek (), os);
                        --melyseg;
                    }
                }
                void szabadit (Csomopont * elem)
                {
                    if (elem != NULL)
                    {
                        szabadit (elem->egyesGyermek ());
                        szabadit (elem->nullasGyermek ());
                        delete elem;
                    }
                }
            protected:
                Csomopont gyoker;
                int maxMelyseg;
                double atlag, szoras;

                void rmelyseg (Csomopont * elem);
                void ratlag (Csomopont * elem);
                void rszoras (Csomopont * elem);
            };
            int
            LZWBinFa::getMelyseg (void)
            {
                melyseg = maxMelyseg = 0;
                rmelyseg (&gyoker);
                return maxMelyseg - 1;
            }
            double
            LZWBinFa::getAtlag (void)
            {
                melyseg = atlagosszeg = atlagdb = 0;
                ratlag (&gyoker);
                atlag = ((double) atlagosszeg) / atlagdb;
                return atlag;
            }
            double
            LZWBinFa::getSzoras (void)
            {
                atlag = getAtlag ();
                szorasosszeg = 0.0;
                melyseg = atlagdb = 0;

                rszoras (&gyoker);
                if (atlagdb - 1 > 0)
                    szoras = std::sqrt (szorasosszeg / (atlagdb - 1));
                else
                    szoras = std::sqrt (szorasosszeg);
                return szoras;
            }
            void
            LZWBinFa::rmelyseg (Csomopont * elem)
            {
                if (elem != NULL)
                {
                    ++melyseg;
                    if (melyseg > maxMelyseg)
                        maxMelyseg = melyseg;
                    rmelyseg (elem->egyesGyermek ());
                    rmelyseg (elem->nullasGyermek ());
                    --melyseg;
                }
            }
            void
            LZWBinFa::ratlag (Csomopont * elem)
            {
                if (elem != NULL)
                {
                    ++melyseg;
                    ratlag (elem->egyesGyermek ());
                    ratlag (elem->nullasGyermek ());
                    --melyseg;
                    if (elem->egyesGyermek () == NULL && elem->nullasGyermek () == NULL)
                    {
                        ++atlagdb;
                        atlagosszeg += melyseg;
                    }
                }
            }
            void
            LZWBinFa::rszoras (Csomopont * elem)
            {
                if (elem != NULL)
                {
                    ++melyseg;
                    rszoras (elem->egyesGyermek ());
                    rszoras (elem->nullasGyermek ());
                    --melyseg;
                    if (elem->egyesGyermek () == NULL && elem->nullasGyermek () == NULL)
                    {
                        ++atlagdb;
                        szorasosszeg += ((melyseg - atlag) * (melyseg - atlag));
                    }
                }
            }
            void
            usage (void)
            {
                std::cout << "Usage: lzwtree in_file -o out_file" << std::endl;
            }
            int
            main (int argc, char *argv[])
            {
                if (argc != 4)
                {
                    usage ();
                    return -1;
                }
                char *inFile = *++argv;
                if (*((*++argv) + 1) != 'o')
                {
                    usage ();
                    return -2;
                }
                std::fstream beFile (inFile, std::ios_base::in);

                if (!beFile)
                {
                    std::cout << inFile << " nem letezik..." << std::endl;
                    usage ();
                    return -3;
                }
                std::fstream kiFile (*++argv, std::ios_base::out);

                unsigned char b;
                LZWBinFa binFa;

                while (beFile.read ((char *) &b, sizeof (unsigned char)))
                    if (b == 0x0a)
                        break;
                bool kommentben = false;

                while (beFile.read ((char *) &b, sizeof (unsigned char)))
                {
                    if (b == 0x3e)
                    {			// > karakter
                        kommentben = true;
                        continue;
                    }
                    if (b == 0x0a)
                    {			// újsor
                        kommentben = false;
                        continue;
                    }
                    if (kommentben)
                        continue;
                    if (b == 0x4e)		// N betű
                        continue;
                    for (int i = 0; i < 8; ++i)
                    {
                        if (b & 0x80)
                            binFa << '1';
                        else
                            binFa << '0';
                        b <<= 1;
                    }
                }
                kiFile << binFa;
                kiFile << "depth = " << binFa.getMelyseg () << std::endl;
                kiFile << "mean = " << binFa.getAtlag () << std::endl;
                kiFile << "var = " << binFa.getSzoras () << std::endl;

                kiFile.close ();
                beFile.close ();
                return 0;
            }]]></programlisting>
        <para>
           <emphasis role = "strong">Tanulságok, tapasztalatok, magyarázat:</emphasis>
        </para>
        <para>
            Az LZWBinFa osztály építi fel a bemeneti fájl bináris fáját. Így használjuk: 
            <code>./binfa [bemenő fájl] -o [kimenő fájl]</code>.
	</para>
	<para>
            Egy bináris fa felépítése:
	</para>
            <itemizedlist>
		<listitem>
                    <para>
			Ha 0-st kell betenni a fába, úgy meg kell néznünk, hogy
			az aktuális csomópont tartalmaz e 0-s elemet
                            <itemizedlist>
				<listitem><para>HA NEM TARTALMAZ, akkor betesszük a nullás gyermekének a 0-t</para></listitem>
				<listitem><para>HA TARTALMAZ, úgy létre kell hoznunk egy új csomópontot és az ő gyermekeként tesszük be a 0-st</para></listitem>
                            </itemizedlist>
                    </para>
		</listitem>
		</itemizedlist>
	<para>
            Az 1-es betétele esetén is a lépések ugyanezek.
	</para>
         <figure>
		<title>A 011010 bináris fája</title>
                    <mediaobject>
			<imageobject>
                            <imagedata fileref="./pictures/binfa.png"  width="50%"/>
			</imageobject>
                    </mediaobject>
            </figure>
    </section>        
        
    <section>
        <title>III. Fabejárás</title>
        <caution>
            <title>Tutorált</title>
            <para>
                Ebben a feladatban tutorált Duszka Ákos Attila.
            </para>
        </caution>
        <para>
            Járd be az előző (inorder bejárású) fát pre- és posztorder is!
        </para>
        <para>
           <emphasis role = "strong">Tanulságok, tapasztalatok, magyarázat:</emphasis>
        </para>
	<para>
            Preorder bejárás esetén a gyökérrel kezdünk, majd bejárjuk a baloldali részfát,
            azt követően pedig a jobboldali részfát.
	</para>
	<para>
            Postorder bejárás esetén pedig szintén a gyökérrel kezdünk, viszont a jobboldali
            részfával folytatjuk, és a baloldali részfával végzünk.
	</para>
	<para>
            Inorder bejárás esetén a bal oldali részfát követően bejárjuk a gyökeret,
            majd a jobboldali részfát.
	</para>
	<para>
            A program futtatása mostmár a következőképpen néz ki:
            <code>./binfa befile -o kifile [o/r]</code> ahol az o postorder,
            az r pedig preorder bejárást jelent. De mindezt a Makefile
            tartalmazza, tehát az olvasó könnyen és egyszerűen kipróbálhatja
            és tanulmányozhatja a programot.
	</para>
		<screen>
<![CDATA[========PREORDER BEJARAS=========
---------------0(5)
------------0(4)
---------------1(5)
---------0(3)
---------------0(5)
------------1(4)
------------------0(6)
---------------1(5)
------------------1(6)
------0(2)
---------------0(5)
------------0(4)
---------1(3)
------------------0(6)
---------------0(5)
------------1(4)
---------------1(5)
---/(1)
---------0(3)
------------1(4)
------1(2)
---------------0(5)
------------0(4)
---------1(3)
------------1(4)
depth = 5
mean = 4.09091
var = 0.700649
========POSTORDER BEJARAS========
------------1(4)
---------1(3)
------------0(4)
---------------0(5)
------1(2)
------------1(4)
---------0(3)
---/(1)
---------------1(5)
------------1(4)
---------------0(5)
------------------0(6)
---------1(3)
------------0(4)
---------------0(5)
------0(2)
------------------1(6)
---------------1(5)
------------------0(6)
------------1(4)
---------------0(5)
---------0(3)
---------------1(5)
------------0(4)
---------------0(5)
depth = 5
mean = 4.09091
var = 0.700649]]>
</screen>
    </section>        
                        
    <section>
        <title>IV. Tag a gyökér</title>
        <para>
            Az LZW algoritmust ültesd át egy C++ osztályba, legyen egy Tree és egy beágyazott Node
            osztálya. A gyökér csomópont legyen kompozícióban a fával!
        </para>
        <para>
            Megoldás forrása:                
        </para>
        <programlisting>
<![CDATA[// z3a7.cpp

#include <iostream>		// mert olvassuk a std::cin, írjuk a std::cout csatornákat
#include <cmath>		// mert vonunk gyököt a szóráshoz: std::sqrt
#include <fstream>		// fájlból olvasunk, írunk majd

class LZWBinFa
{
public:
    LZWBinFa ():fa (&gyoker)
    {
    }
    ~LZWBinFa ()
    {
        szabadit (gyoker.egyesGyermek ());
        szabadit (gyoker.nullasGyermek ());
    }

    void operator<< (char b)
    {
        if (b == '0')
        {
            if (!fa->nullasGyermek ())
            {
                Csomopont *uj = new Csomopont ('0');
                fa->ujNullasGyermek (uj);
                fa = &gyoker;
            }
            else
            {
                fa = fa->nullasGyermek ();
            }
        }
        
        // Mit kell betenni éppen, vagy '1'-et?
        else
        {
            if (!fa->egyesGyermek ())
            {
                Csomopont *uj = new Csomopont ('1');
                fa->ujEgyesGyermek (uj);
                fa = &gyoker;
            }
            else
            {
                fa = fa->egyesGyermek ();
            }
        }
    }
    void kiir (void)
    {
        melyseg = 0;
        kiir (&gyoker, std::cout);
    }

    int getMelyseg (void);
    double getAtlag (void);
    double getSzoras (void);

    friend std::ostream & operator<< (std::ostream & os, LZWBinFa & bf)
    {
        bf.kiir (os);
        return os;
    }
    void kiir (std::ostream & os)
    {
        melyseg = 0;
        kiir (&gyoker, os);
    }
    
private:
    class Csomopont
    {
    public:
        Csomopont (char b = '/'):betu (b), balNulla (0), jobbEgy (0)
        {
        };
        ~Csomopont ()
        {
        };
        Csomopont *nullasGyermek () const
        {
            return balNulla;
        }
        Csomopont *egyesGyermek () const
        {
            return jobbEgy;
        }
        void ujNullasGyermek (Csomopont * gy)
        {
            balNulla = gy;
        }
        void ujEgyesGyermek (Csomopont * gy)
        {
            jobbEgy = gy;
        }
        char getBetu () const
        {
            return betu;
        }

    private:
        char betu;
        Csomopont *balNulla;
        Csomopont *jobbEgy;
        Csomopont (const Csomopont &); //másoló konstruktor
        Csomopont & operator= (const Csomopont &);
    };
    
    Csomopont *fa;
    int melyseg, atlagosszeg, atlagdb;
    double szorasosszeg;

	//nocopy
	LZWBinFa (const LZWBinFa &);
    LZWBinFa & operator= (const LZWBinFa &);

    void kiir (Csomopont * elem, std::ostream & os)
    {
        if (elem != NULL)
        {
            ++melyseg;
            kiir (elem->egyesGyermek (), os);
            for (int i = 0; i < melyseg; ++i)
                os << "---";
            os << elem->getBetu () << "(" << melyseg - 1 << ")" << std::endl;
            kiir (elem->nullasGyermek (), os);
            --melyseg;
        }
    }
    void szabadit (Csomopont * elem)
    {
        if (elem != NULL)
        {
            szabadit (elem->egyesGyermek ());
            szabadit (elem->nullasGyermek ());
            delete elem;
        }
    }
protected:
    Csomopont gyoker;
    int maxMelyseg;
    double atlag, szoras;

    void rmelyseg (Csomopont * elem);
    void ratlag (Csomopont * elem);
    void rszoras (Csomopont * elem);

};

int
LZWBinFa::getMelyseg (void)
{
    melyseg = maxMelyseg = 0;
    rmelyseg (&gyoker);
    return maxMelyseg - 1;
}

double
LZWBinFa::getAtlag (void)
{
    melyseg = atlagosszeg = atlagdb = 0;
    ratlag (&gyoker);
    atlag = ((double) atlagosszeg) / atlagdb;
    return atlag;
}

double
LZWBinFa::getSzoras (void)
{
    atlag = getAtlag ();
    szorasosszeg = 0.0;
    melyseg = atlagdb = 0;

    rszoras (&gyoker);

    if (atlagdb - 1 > 0)
        szoras = std::sqrt (szorasosszeg / (atlagdb - 1));
    else
        szoras = std::sqrt (szorasosszeg);

    return szoras;
}

void
LZWBinFa::rmelyseg (Csomopont * elem)
{
    if (elem != NULL)
    {
        ++melyseg;
        if (melyseg > maxMelyseg)
            maxMelyseg = melyseg;
        rmelyseg (elem->egyesGyermek ());
        rmelyseg (elem->nullasGyermek ());
        --melyseg;
    }
}

void
LZWBinFa::ratlag (Csomopont * elem)
{
    if (elem != NULL)
    {
        ++melyseg;
        ratlag (elem->egyesGyermek ());
        ratlag (elem->nullasGyermek ());
        --melyseg;
        if (elem->egyesGyermek () == NULL && elem->nullasGyermek () == NULL)
        {
            ++atlagdb;
            atlagosszeg += melyseg;
        }
    }
}
void
LZWBinFa::rszoras (Csomopont * elem)
{
    if (elem != NULL)
    {
        ++melyseg;
        rszoras (elem->egyesGyermek ());
        rszoras (elem->nullasGyermek ());
        --melyseg;
        if (elem->egyesGyermek () == NULL && elem->nullasGyermek () == NULL)
        {
            ++atlagdb;
            szorasosszeg += ((melyseg - atlag) * (melyseg - atlag));
        }
    }
}

void
usage (void)
{
    std::cout << "Usage: lzwtree in_file -o out_file" << std::endl;
}

int
main (int argc, char *argv[])
{
    if (argc != 4)
    {
        usage ();
        return -1;
    }

    char *inFile = *++argv;

    if (*((*++argv) + 1) != 'o')
    {
        usage ();
        return -2;
    }

    std::fstream beFile (inFile, std::ios_base::in);

    if (!beFile)
    {
        std::cout << inFile << " nem letezik..." << std::endl;
        usage ();
        return -3;
    }

    std::fstream kiFile (*++argv, std::ios_base::out);

    unsigned char b;
    LZWBinFa binFa;

    while (beFile.read ((char *) &b, sizeof (unsigned char)))
        if (b == 0x0a)
            break;

    bool kommentben = false;

    while (beFile.read ((char *) &b, sizeof (unsigned char)))
    {

        if (b == 0x3e)
        {			// > karakter
            kommentben = true;
            continue;
        }

        if (b == 0x0a)
        {			// újsor
            kommentben = false;
            continue;
        }

        if (kommentben)
            continue;

        if (b == 0x4e)		// N betű
            continue;

        for (int i = 0; i < 8; ++i)
        {
            if (b & 0x80)
                binFa << '1';
            else
                binFa << '0';
            b <<= 1;
        }

    }
    kiFile << binFa;
    kiFile << "depth = " << binFa.getMelyseg () << std::endl;
    kiFile << "mean = " << binFa.getAtlag () << std::endl;
    kiFile << "var = " << binFa.getSzoras () << std::endl;

    kiFile.close ();
    beFile.close ();

    return 0;
}]]></programlisting>
        <para>
           <emphasis role = "strong">Tanulságok, tapasztalatok, magyarázat:</emphasis>
        </para>
        <para>
            Ebben az esetben felhaszáljuk a már megírt LZWBinFa programot, mely
            eleve úgy lett megírva, hogy a gyökér kompozícióban van a fával.
        </para>
    </section>        
                
    <section>
        <title>V. Mutató a gyökér</title>
        <para>
            Írd át az előző forrást, hogy a gyökér csomópont ne kompozícióban, csak aggregációban legyen a 
            fával!
        </para>
        <para>
            Megoldás forrása:  
        </para>
        <programlisting><![CDATA[
            #include <iostream>
            #include <cmath>
            #include <fstream>

            class LZWBinFa
            {
                    public:
                            LZWBinFa ():fa (gyoker = new Csomopont('/'))
                    {
                    }

                            ~LZWBinFa ()
                            {
                                    szabadit (gyoker->egyesGyermek());
                                    szabadit (gyoker->nullasGyermek());
                                    delete gyoker;
                            }

                            void operator<< (char b)
                            {
                                    if (b == '0')
                                    {
                                            if (!fa->nullasGyermek())
                                            {
                                                    Csomopont *uj = new Csomopont ('0');
                                                    fa->ujNullasGyermek (uj);
                                                    fa = gyoker;
                                            }
                                            else
                                            {
                                                    fa = fa->nullasGyermek ();
                                            }
                                    }

                                    else
                                    {
                                            if (!fa->egyesGyermek ())
                                            {
                                                    Csomopont *uj = new Csomopont ('1');
                                                    fa->ujEgyesGyermek (uj);
                                                    fa = gyoker;
                                            }
                                            else
                                            {
                                                    fa = fa->egyesGyermek ();
                                            }
                                    }
                            }

                            void kiir (void)
                            {
                                    melyseg = 0;
                                    kiir (gyoker, std::cout);
                            }

                            int getMelyseg (void);
                            double getAtlag (void);
                            double getSzoras (void);

                            friend std::ostream & operator<< (std::ostream & os, LZWBinFa & bf)
                            {
                                    bf.kiir (os);
                                    return os;
                            }

                            void kiir (std::ostream & os)
                            {
                                    melyseg = 0;
                                    kiir (gyoker, os);
                            }

                    private:
            
                            class Csomopont
                            {
                                    public:
                                            Csomopont (char b = '/'):betu (b), balNulla (0), jobbEgy (0)
                                    {
                                    };

                                            ~Csomopont ()
                                            {
                                            };

                                            Csomopont *nullasGyermek () const
                                            {
                                                    return balNulla;
                                            }
                                            Csomopont *egyesGyermek () const
                                            {
                                                    return jobbEgy;
                                            }
                                            void ujNullasGyermek (Csomopont * gy)
                                            {
                                                    balNulla = gy;
                                            }
                                            void ujEgyesGyermek (Csomopont * gy)
                                            {
                                                    jobbEgy = gy;
                                            }
                                            char getBetu () const
                                            {
                                                    return betu;
                                            }

                                    private:
                                            char betu;
                                            Csomopont *balNulla;
                                            Csomopont *jobbEgy;
                                            Csomopont (const Csomopont &);
                                            Csomopont & operator= (const Csomopont &);
                            };

                            Csomopont *fa;
                            int melyseg, atlagosszeg, atlagdb;
                            double szorasosszeg;
                            LZWBinFa (const LZWBinFa &);
                            LZWBinFa & operator= (const LZWBinFa &);

                            void kiir (Csomopont * elem, std::ostream & os)
                            {
                                    if (elem != nullptr)
                                    {
                                            ++melyseg;
                                            kiir (elem->egyesGyermek (), os);
                                            for (int i = 0; i < melyseg; ++i)
                                                    os << "---";
                                            os << elem->getBetu () << "(" << melyseg - 1 << ")" << std::endl;
                                            kiir (elem->nullasGyermek (), os);
                                            --melyseg;
                                    }
                            }

                            void szabadit (Csomopont * elem)
            
                            {
                                    if (elem != nullptr)
                                    {
                                            szabadit (elem->egyesGyermek ());
                                            szabadit (elem->nullasGyermek ());
                                            delete elem;
                                    }
                            }

                    protected:
                            // A fában tagként benne van egy csomópont, ez erősen ki van tüntetve, Ő a gyökér:
                            Csomopont * gyoker = new Csomopont('/');
                            int maxMelyseg;
                            double atlag, szoras;

                            void rmelyseg (Csomopont * elem);
                            void ratlag (Csomopont * elem);
                            void rszoras (Csomopont * elem);

            };

                    int
            LZWBinFa::getMelyseg (void)
            {
                    melyseg = maxMelyseg = 0;
                    rmelyseg (gyoker);
                    return maxMelyseg - 1;
            }

                    double
            LZWBinFa::getAtlag (void)
            {
                    melyseg = atlagosszeg = atlagdb = 0;
                    ratlag (gyoker);
                    atlag = ((double) atlagosszeg) / atlagdb;
                    return atlag;
            }

                    double
            LZWBinFa::getSzoras (void)
            {
                    atlag = getAtlag ();
                    szorasosszeg = 0.0;
                    melyseg = atlagdb = 0;

                    rszoras (gyoker);

                    if (atlagdb - 1 > 0)
                            szoras = std::sqrt (szorasosszeg / (atlagdb - 1));
                    else
                            szoras = std::sqrt (szorasosszeg);

                    return szoras;
            }

                    void
            LZWBinFa::rmelyseg (Csomopont * elem)
            {
                    if (elem != nullptr)
                    {
                            ++melyseg;
                            if (melyseg > maxMelyseg)
                                    maxMelyseg = melyseg;
                            rmelyseg (elem->egyesGyermek ());
                            rmelyseg (elem->nullasGyermek ());
                            --melyseg;
                    }
            }

                    void
            LZWBinFa::ratlag (Csomopont * elem)
            {
                    if (elem != nullptr)
                    {
                            ++melyseg;
                            ratlag (elem->egyesGyermek ());
                            ratlag (elem->nullasGyermek ());
                            --melyseg;
                            if (elem->egyesGyermek () == nullptr && elem->nullasGyermek () == nullptr)
                            {
                                    ++atlagdb;
                                    atlagosszeg += melyseg;
                            }
                    }
            }

                    void
            LZWBinFa::rszoras (Csomopont * elem)
            {
                    if (elem != nullptr)
                    {
                            ++melyseg;
                            rszoras (elem->egyesGyermek ());
                            rszoras (elem->nullasGyermek ());
                            --melyseg;
                            if (elem->egyesGyermek () == nullptr && elem->nullasGyermek () == nullptr)
                            {
                                    ++atlagdb;
                                    szorasosszeg += ((melyseg - atlag) * (melyseg - atlag));
                            }
                    }
            }

                    void
            usage (void)
            {
                    std::cout << "Usage: lzwtree in_file -o out_file" << std::endl;
            }

                    int
            main (int argc, char *argv[])
            {
                    if (argc != 4)
                    {
                            usage ();
                            return -1;
                    }

                    char *inFile = *++argv;

                    if (*((*++argv) + 1) != 'o')
                    {
                            usage ();
                            return -2;
                    }

                    std::fstream beFile (inFile, std::ios_base::in);

                    if (!beFile)
                    {
                            std::cout << inFile << " nem letezik..." << std::endl;
                            usage ();
                            return -3;
                    }

                    std::fstream kiFile (*++argv, std::ios_base::out);

                    unsigned char b;
                    LZWBinFa binFa;

                    while (beFile.read ((char *) &b, sizeof (unsigned char)))
                            if (b == 0x0a)
                                    break;

                    bool kommentben = false;

                    while (beFile.read ((char *) &b, sizeof (unsigned char)))
                    {

                            if (b == 0x3e)
                            {			// > karakter
                                    kommentben = true;
                                    continue;
                            }

                            if (b == 0x0a)
                            {			// újsor
                                    kommentben = false;
                                    continue;
                            }

                            if (kommentben)
                                    continue;

                            if (b == 0x4e)		// N betű
                                    continue;

                            for (int i = 0; i < 8; ++i)
                            {
                                    if (b & 0x80)
                                            binFa << '1';
                                    else
                                            binFa << '0';
                                    b <<= 1;
                            }

                    }

                    kiFile << binFa;

                    kiFile << "depth = " << binFa.getMelyseg () << std::endl;
                    kiFile << "mean = " << binFa.getAtlag () << std::endl;
                    kiFile << "var = " << binFa.getSzoras () << std::endl;

                    kiFile.close ();
                    beFile.close ();

                    return 0;
            }


        ]]></programlisting>

        <para>
           <emphasis role = "strong">Tanulságok, tapasztalatok, magyarázat:</emphasis>
        </para>
        <para>
			Itt úgy írtuk át a már meglévő BinFa
			programunkat, hogy a bináris fánk gyökere mutató legyen.
	</para>
	<para>
            Egyszerű a módosítások elvégzése.A gyökér csomópont definíciójánál foglalunk helyet a heapen 
            a gyökérnek, majd az ebből kapott mutatót behelyettesítjük az olyan helykre, ahol egyébként a 
            gyökér változóra hivatkoztunk.
        </para>
    </section>                     

    <section>
        <title>VI. Mozgató szemantika</title>
        <para>
            Írj az előző programhoz mozgató konstruktort és értékadást, a mozgató konstruktor legyen a mozgató
            értékadásra alapozva!
        </para>
        <para>
            Megoldás forrása:  
        </para>
        <programlisting><![CDATA[
            #include <iostream>
#include <cmath>
#include <fstream>

class LZWBinFa {
	public:
		LZWBinFa() {
			gyoker = new Csomopont('/');
			fa = gyoker;
		}
		~LZWBinFa() {
			szabadit(gyoker->egyesGyermek());
			szabadit(gyoker->nullasGyermek());
			delete gyoker;
		}

		LZWBinFa(const LZWBinFa & regi) {
			std::cout << "LZWBinFa copy ctor" << std::endl;
			gyoker = masol(regi.gyoker, regi.fa);
		}

		LZWBinFa & operator=(LZWBinFa & regi) {
			std::cout << "mozgato ctor" << std::endl;
			this->gyoker = regi.gyoker;
			this->fa = regi.fa;
			return *this;
		}

		LZWBinFa & operator<<(char b) {
			if (b == '0') {
				if (!fa->nullasGyermek()) {	// ha nincs, hát akkor csinálunk
					Csomopont *uj = new Csomopont('0');
					fa->ujNullasGyermek(uj);
					fa = gyoker;
				} else {	// ha van, arra rálépünk
					fa = fa->nullasGyermek();
				}
			}
			else {
				if (!fa->egyesGyermek()) {
					Csomopont *uj = new Csomopont('1');
					fa->ujEgyesGyermek(uj);
					fa = gyoker;
				} else {
					fa = fa->egyesGyermek();
				}
			}

			return *this;
		}

		void kiir(void) {
			melyseg = 0;
			kiir(gyoker, std::cout);
		}

		int getMelyseg(void);
		double getAtlag(void);
		double getSzoras(void);

		friend std::ostream & operator<<(std::ostream & os, LZWBinFa & bf) {
			bf.kiir(os);
			return os;
		}
		void kiir(std::ostream & os) {
			melyseg = 0;
			kiir(gyoker, os);
		}

	private:
		class Csomopont {
			public:
				Csomopont(char b = '/'):betu(b), balNulla(0), jobbEgy(0) {
				};
				~Csomopont() {
				};
				Csomopont *nullasGyermek() const {
					return balNulla;
				} Csomopont *egyesGyermek() const {
					return jobbEgy;
				}
				void ujNullasGyermek(Csomopont * gy) {
					balNulla = gy;
				}
				void ujEgyesGyermek(Csomopont * gy) {
					jobbEgy = gy;
				}
				char getBetu() const {
					return betu;
				}

				char betu;
				Csomopont *balNulla;
				Csomopont *jobbEgy;
				Csomopont(const Csomopont &);
				Csomopont & operator=(const Csomopont &);

		};

		Csomopont *fa;
		int melyseg, atlagosszeg, atlagdb;
		double szorasosszeg;

		void kiir(Csomopont * elem, std::ostream & os) {
			if (elem != NULL) {
				++melyseg;
				kiir(elem->egyesGyermek(), os);
				for (int i = 0; i < melyseg; ++i)
					os << "---";

				os << elem->getBetu() << "(" << melyseg -
					1 << ")" << std::endl;
				kiir(elem->nullasGyermek(), os);
				--melyseg;
			}
		}

		void szabadit(Csomopont * elem) {
			if (elem != NULL) {
				szabadit(elem->egyesGyermek());
				szabadit(elem->nullasGyermek());
				delete elem;
			}
		}

		Csomopont *masol(Csomopont * elem, Csomopont * regifa) {
			Csomopont *ujelem = NULL;
			if (elem != NULL) {
				switch (elem->getBetu()) {
					case '/':
						ujelem = new Csomopont('/');
						break;
					case '0':
						ujelem = new Csomopont('1');
						break;
					case '1':
						ujelem = new Csomopont('0');
						break;
					default:
						std::cerr << "HIBA!" << std::endl;
						break;
				}
				ujelem->ujEgyesGyermek(masol
						(elem->egyesGyermek(), regifa));
				ujelem->ujNullasGyermek(masol
						(elem->nullasGyermek(),
						 regifa));
				if (regifa == elem)
					fa = ujelem;

			}

			return ujelem;
		}

	protected:
		Csomopont * gyoker;
		int maxMelyseg;
		double atlag, szoras;

		void rmelyseg(Csomopont * elem);
		void ratlag(Csomopont * elem);
		void rszoras(Csomopont * elem);
};

int LZWBinFa::getMelyseg(void)
{
	melyseg = maxMelyseg = 0;
	rmelyseg(gyoker);
	return maxMelyseg - 1;
}

double LZWBinFa::getAtlag(void)
{
	melyseg = atlagosszeg = atlagdb = 0;
	ratlag(gyoker);
	atlag = ((double)atlagosszeg) / atlagdb;
	return atlag;
}

double LZWBinFa::getSzoras(void)
{
	atlag = getAtlag();
	szorasosszeg = 0.0;
	melyseg = atlagdb = 0;

	rszoras(gyoker);

	if (atlagdb - 1 > 0)
		szoras = std::sqrt(szorasosszeg / (atlagdb - 1));
	else
		szoras = std::sqrt(szorasosszeg);

	return szoras;
}

void LZWBinFa::rmelyseg(Csomopont * elem)
{
	if (elem != NULL) {
		++melyseg;
		if (melyseg > maxMelyseg)
			maxMelyseg = melyseg;
		rmelyseg(elem->egyesGyermek());
		rmelyseg(elem->nullasGyermek());
		--melyseg;
	}
}

void LZWBinFa::ratlag(Csomopont * elem)
{
	if (elem != NULL) {
		++melyseg;
		ratlag(elem->egyesGyermek());
		ratlag(elem->nullasGyermek());
		--melyseg;
		if (elem->egyesGyermek() == NULL
				&& elem->nullasGyermek() == NULL) {
			++atlagdb;
			atlagosszeg += melyseg;
		}
	}
}

void LZWBinFa::rszoras(Csomopont * elem)
{
	if (elem != NULL) {
		++melyseg;
		rszoras(elem->egyesGyermek());
		rszoras(elem->nullasGyermek());
		--melyseg;
		if (elem->egyesGyermek() == NULL
				&& elem->nullasGyermek() == NULL) {
			++atlagdb;
			szorasosszeg += ((melyseg - atlag) * (melyseg - atlag));
		}
	}
}

void usage(void)
{
	std::cout << "Usage: lzwtree in_file -o out_file" << std::endl;
}

void fgv(LZWBinFa binFa) {
	std::cout << binFa;
	std::cout << "depth = " << binFa.getMelyseg() << std::endl;
	std::cout << "mean = " << binFa.getAtlag() << std::endl;
	std::cout << "var = " << binFa.getSzoras() << std::endl;
}

int main(int argc, char *argv[])
{
	if (argc != 4) {
		usage();
		return -1;
	}

	char *inFile = *++argv;

	if (*((*++argv) + 1) != 'o') {
		usage();
		return -2;
	}

	std::fstream beFile(inFile, std::ios_base::in);

	if (!beFile) {
		std::cout << inFile << " nem letezik..." << std::endl;
		usage();
		return -3;
	}

	std::fstream kiFile(*++argv, std::ios_base::out);

	unsigned char b;
	LZWBinFa binFa, binFa2;

	bool kommentben = false;
	while (beFile.read((char *)&b, sizeof(unsigned char))) {
		if (b == 0x3e) {	// > karakter
			kommentben = true;
			continue;
		}

		if (b == 0x0a) {	// újsor
			kommentben = false;
			continue;
		}

		if (kommentben)
			continue;

		if (b == 0x4e)	// N betű
			continue;

		for (int i = 0; i < 8; ++i) {
			if (b & 0x80)
				binFa << '1';
			else
				binFa << '0';
			b <<= 1;
		}
	}

	// Kipróbáljuk a másoló ctort
	fgv(binFa);

	// Kiírjuk az eredeti fát, mint eddig.
	kiFile << binFa;
	kiFile << "depth = " << binFa.getMelyseg() << std::endl;
	kiFile << "mean = " << binFa.getAtlag() << std::endl;
	kiFile << "var = " << binFa.getSzoras() << std::endl;

	// Átmozgatjuk a fát binFa2-be.
	binFa2 = binFa;

	// Majd kiírjuk ezt
	kiFile << binFa2;
	kiFile << "depth = " << binFa2.getMelyseg() << std::endl;
	kiFile << "mean = " << binFa2.getAtlag() << std::endl;
	kiFile << "var = " << binFa2.getSzoras() << std::endl;

	kiFile.close();
	beFile.close();

	return 0;
}
        ]]></programlisting>
        <para>
           <emphasis role = "strong">Tanulságok, tapasztalatok, magyarázat:</emphasis>
        </para>
        <para>
            A mozgató szemantika alatt a másoló-, és mozgató-konstruktorokat és a destruktort értjük. 
            A bináris fák másolásához és mozgatásához rekurzív mozgató-, és másoló függvényekre lesz 
            szükségünk.
	</para>
		<programlisting language="C++">
<![CDATA[Csomopont *  masol ( Csomopont * elem, Csomopont * regifa ) {
     Csomopont * ujelem = NULL;
     if ( elem != NULL ) {
         switch (elem->getBetu()) {
			 case '/':
				 ujelem = new Csomopont ( '/' );
				 break;
			 case '0':
				 ujelem = new Csomopont ( '1' );
				 break;
			 case '1':
				 ujelem = new Csomopont ( '0' );
				 break;
			 default:
				 std::cerr<<"HIBA!"<<std::endl;
				 break;
         }
		 ujelem->ujEgyesGyermek(
			 masol(elem->egyesGyermek(), regifa)
		 );
		 ujelem->ujNullasGyermek(
			 masol(elem->nullasGyermek(), regifa)
		 );
         if ( regifa == elem )
              fa = ujelem;
     }
     return ujelem;
}]]>
		</programlisting>
	<para>
            Az LZWBinFa osztályunk úgy épül fel, hogy az LZWBinFa osztályon belül megtalálhatóak 
            beágyazott <code>Csomopont</code> osztályú objektumok, melyek alkotják a fát. Ebből 
            következik, hogy a fát úgy tudjuk másolni, hogy ezeket a beágyazott csomópontokat rekurzívan 
            másoljuk.
	</para>
	
	<para>
            Ennek alapjára el tudjuk készíteni a mozgatókonstruktort is. Ami azt jelenti, hogy felül 
            fogjuk terhelni a '=' operátort (operator overloading).
	</para>
		<programlisting language="C++">
<![CDATA[LZWBinFa & operator=(LZWBinFa & regi) {
	std::cout << "mozgato ctor" << std::endl;
	this->gyoker = regi.gyoker;
	this->fa = regi.fa;
	return *this;
}]]>
		</programlisting>
		<screen>
<![CDATA[LZWBinFa copy ctor
------------0(3)
---------0(2)
------------1(3)
---------------1(4)
------0(1)
------------0(3)
---------1(2)
---/(0)
---------------0(4)
------------0(3)
---------------1(4)
------------------1(5)
---------0(2)
------------1(3)
---------------1(4)
------1(1)
------------------0(5)
---------------0(4)
------------------1(5)
------------0(3)
---------------1(4)
---------1(2)
---------------0(4)
------------1(3)
---------------1(4)
depth = 5
mean = 4.09091
var = 0.700649
mozgato ctor
------------1(3)
---------1(2)
------------0(3)
---------------0(4)
------1(1)
------------1(3)
---------0(2)
---/(0)
---------------1(4)
------------1(3)
---------------0(4)
------------------0(5)
---------1(2)
------------0(3)
---------------0(4)
------0(1)
------------------1(5)
---------------1(4)
------------------0(5)
------------1(3)
---------------0(4)
---------0(2)
---------------1(4)
------------0(3)
---------------0(4)
depth = 5
mean = 4.09091
var = 0.700649
------------1(3)
---------1(2)
------------0(3)
---------------0(4)
------1(1)
------------1(3)
---------0(2)
---/(0)
---------------1(4)
------------1(3)
---------------0(4)
------------------0(5)
---------1(2)
------------0(3)
---------------0(4)
------0(1)
------------------1(5)
---------------1(4)
------------------0(5)
------------1(3)
---------------0(4)
---------0(2)
---------------1(4)
------------0(3)
---------------0(4)
depth = 5
mean = 4.09091
var = 0.700649]]>
		</screen>
    </section>                     
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                        
</chapter>                
