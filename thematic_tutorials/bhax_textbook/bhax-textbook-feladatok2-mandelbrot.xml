<chapter xmlns="http://docbook.org/ns/docbook" xmlns:xlink="http://www.w3.org/1999/xlink" xmlns:xi="http://www.w3.org/2001/XInclude" version="5.0" xml:lang="hu">
    <info>
        <title>Helló, Mandelbrot!</title>
        <keywordset>
            <keyword/>
        </keywordset>
    </info>

    <section>
        <title>I. Reverse engineering UML osztálydiagram</title>
        
        <programlisting language = "java"><![CDATA[\documentclass[a4paper]{article}

\usepackage[utf8]{inputenc}
\usepackage[magyar]{babel}
\usepackage[T1]{fontenc}
\usepackage[a4paper, margin=2cm]{geometry}
\usepackage[magyar]{babel}
\usepackage{tikz-uml}

\pdfsuppresswarningpagegroup=1
\setlength{\parindent}{0em} % A bekezedések elott nem hagy ures helyet
\pagenumbering{gobble} % Kikapcsolja az oldalszámokat

\begin{document}

\begin{figure}[htpb]
\begin{center}
\begin{tikzpicture}[scale=1, transform shape]
    \begin{umlpackage}[x=0, y=0]{LZWBinFa}
        \umlclass{LZWBinFa}
        {
            - fa : Csomopont* \\
            - melyseg : int \\
            - atlagosszeg : int \\
            - szorasosszeg : double \\
            \# gyoker : Csomopont \\
            \# maxMelyseg : int \\
            \# atlag : double \\
            \# szoras : double
        }
        {
            + LZWBinFa() <<contructor>> \\
            + $\sim$ LZWBinFa() <<destructor>> \\
            + operator<< (b : char) \\
            + operator<< (os : std::ostream\&, bf : LZWBinFa\&) : std::ostream\& <<friend>> \\
            + kiir() \\
            + kiir(os : std::ostream\&) \\
            + getMelyseg() : int \\
            + getAtlag() : double \\
            + getSzoras() : double \\
            -- LZWBinFa( : const LZWBinFa\&) <<constructor>> \\
            -- operator= (: const LZWBinFa\& ) : LZWBinFa\& \\
            -- kiir(elem : Csomopont*, os : std::ostream\&) \\
            -- szabadit(elem : Csomopont*) \\
            \# rmelyseg(elem : Csomopont*) \\
            \# ratlag(elem : Csomopont*) \\
            \# rszoras(elem : Csomopont*)
        }

        \umlclass[x=4, y=-7]{LZWBinFa::Csomopont}
        {
            -- betu : char \\
            -- balNulla : Csomopont* \\
            -- jobbEgy : Csomopont* \\
        }
        {
            + Csomopont(b : char) <<contructor>> \\
            + $\sim$ Csomopont() <<destructor>> \\
            + const nullasGyermek() : Csomopont* \\
            + const egyesGyermek() : Csomopont* \\
            + ujNullasGyermek(gy : Csomopont*) : Csomopont* \\
            + ujEgyesGyermek(gy : Csomopont*) : Csomopont* \\
            + getBetu() : char \\
            -- Csomopont(const Csomopont\&) <<contructor>>
        }
    \end{umlpackage}
\end{tikzpicture}
\end{center}
\caption{UML osztálydiagramm TeX-ben}%
\label{fig:uml}
\end{figure}

\end{document}]]></programlisting>
        <para>
           <emphasis role = "strong">Tanulságok, tapasztalatok, magyarázat:</emphasis>
        </para> 
        <para>
            Az UML osztálydiagrammok kezdetben tervezésre voltak szánva,
            viszont sok programozó workflow-ja ennek éppen a fordítottja,
            vagyis először programoznak, aztán dokumentálnak. Ennek
            következtében kialakult a szokás, hogy reverse engineering
            jelleggel készítünk UML osztálydiagrammokat, vagyis akkor, mikor
            már a forráskód készen van.
        </para>
        <para>
            Az UML specifikációja viszonylag nagy terjedelmű, viszont ezt nem
            is szükséges ismernünk. Az osztálydiagrammok jelölése a következő
            rendszere a következőképp néz ki: van egy három részre bontott
            téglalapunk, a legfelső részben az osztály neve van.  A következő
            részben a mezők, majd alattuk a metódusok találhatók. A publikus
            adattagok jelölője a <filename>+</filename>, a priváté a
            <filename>-</filename>, a protected láthatóságú adattagokat pedig a
            <filename>#</filename> azonosítja.
        </para>
        <para>
            Számos olyan eszköz van, amely képes forráskódból
            osztálydiagrammokat generálni, az előző felvonásban például az
            Umbrello nevű programot használtuk, azonban most valami mást fogunk
            kipróbálni, névszerint a <link
            xlink:href="http://perso.ensta-paristech.fr/~kielbasi/tikzuml/index.php?lang=en">
            TikZ-UML</link> csomagot a <link
            xlink:href="https://www.latex-project.org/"> LaTeX</link>
            leírónyelvben belül. Ez mind szabad szoftver.
        </para>
        <para>
            Az első védési programhoz, az <filename>LZWBinFá</filename>hoz
            tartozó osztálydigram itt látható.
        </para>
        <figure>
            <title>LZWBinFa UML osztálydiagramm TeX-ben</title>
            <mediaobject>
                <imageobject>
                    <imagedata fileref="./pictures/uml.png" width="70%" />
				</imageobject>
			</mediaobject>
		</figure>
        <para>
            Véleményem szerint TeX-ben sokkal szebb diagrammok készíthetők,
            mint a generáló programokkal, ami nem véletlen, hiszen a TeX
            egy igen népszerű typesetting nyelv, ami jelen van a nyomdákban,
            de legfőbb tudományos publikációk során használatos.
        </para>
        <para>
            Az ábra forráskódja a következőképp nézz ki.
        </para>
        
        <para>
            Amint látjuk, a <filename>LaTeX</filename> szintaxisa egyáltalán
            nem nehéz, könnyen emészthető és könnyen írható, arról nem
            beszélve, hogy gyönyörű dokumentumokat kapunk, melynek minőségét
            semmilyen WYSIWYG szerkesztővel nem lehet megközelíteni.
        </para>
    </section>           

    <section>
        
        <title>II. Forward engineering UML osztálydiagram</title>
        
        <para>
            Ebben a fejezetben megnézzük az UML eredeti rendeltetését,
            miszerint előre megtervezzük az osztályainkat és ebből
            generálunk forráskódot.
        </para>
        <para>
           <emphasis role = "strong">Tanulságok, tapasztalatok, magyarázat:</emphasis>
        </para>
         
        <para>
            Az ötlet a koncepció mögött az, hogy a programozó miután
            megtervezte az osztályokat, már csak a lényges részeket kell, hogy
            kitöltse, és nem kell időt vesztegetni az osztályok, változók,
            metódusok definíciójával.
        </para>
        <para>
            Ebben a példában az Eclipsere épülő Papyrus programot fogjuk
            használni az UML tervezéshez és kódgeneráláshoz. Az Eclipset
            telepíthetük Arch Linuxon például a
        </para>
        <screen>
            <![CDATA[$ pacman -S eclipse-common eclipse-cpp eclipse-java]]>
        </screen>
        <para>
            parancs kiadásával. Ezután telepítsük a Papyrust is az Eclipse
            IDE-n belül az utasítások alapján: <link
            xlink:href="https://www.eclipse.org/papyrus/">
            https://www.eclipse.org/papyrus/</link>.
        </para>
        <para>
            A tervezés elkezdéséhez kiváló walk-through leírás található a
            dokumentációban. Ez a következő linken érhető el: <link
            xlink:href="https://wiki.eclipse.org/Papyrus/Codegen/CppHelloWorld">
            https://wiki.eclipse.org/Papyrus/Codegen/CppHelloWorld</link>.
        </para>
        <para>
            Hogyha kattingatásssal létrehoztuk az osztálydiagrammokat,
            valami ilyesmit kellene, hogy kapjunk:
        </para>
        <figure>
            <title>FW engineering UML osztálydiagramm</title>
            <mediaobject>
                <imageobject>
                    <imagedata fileref="./pictures/uml1.png" width="100%" />
                </imageobject>
            </mediaobject>
        </figure>
         <para>
            Ezután próbáljuk meg kibogáraszni a Eclipse eszköztárából
            a <emphasis role="strong">Generate code</emphasis> opciót,
            és indítsuk el. Ez létre fog hozni nekünk egy új C++
            projektet, ami megfelel annak, amit lerajzolgattunk.
        </para>
        <figure>
            <title>FW engineering C++ kód generálás</title>
            <mediaobject>
                <imageobject>
                    <imagedata fileref="./pictures/uml2.png" width="100%" />
                </imageobject>
            </mediaobject>
        </figure>
        <figure>
            <title>FW engineering C++ kód generálás</title>
            <mediaobject>
                <imageobject>
                    <imagedata fileref="./pictures/uml3.png" width="100%" />
                </imageobject>
            </mediaobject>
        </figure>
        <para>
            A generált kódot már futtathatjuk is, vagy fejleszthetjük
            akár tovább. Véleményem szerint az ilyen kattingatással csak
            drága időt veszünk el önmagunktól...
        </para>    
    </section>
    
    <section>
        
        <title>III. Egy esettan</title>
        
        <para>
            BME C++ könyv 14. fejezetét (427-444 elmélet; 445-469 esettan)
            dolgozzuk fel!
        </para>
        <para>
           <emphasis role = "strong">Megoldás forrása:</emphasis>
        </para>
        <mediaobject>
            <imageobject>
                <imagedata fileref="./pictures/esettan.png"  width="50%"></imagedata>
            </imageobject>
        </mediaobject>
         <programlisting language = "C++"><![CDATA[
        #include "product.h"
#include <string.h>
#include <stdexcept>
using namespace std;
time_t Product::getDateOfAcquisition() const {
    return dateOfAcquisition;
}
int Product::getInitialPrice() const {
    return initialPrice;
}
std::string Product::getName() const {
    return name;
}
Product::Product() {}
Product::Product(std::string name, int initialPrice, time_t dateOfAcquisition): name(name), initialPrice(initialPrice),
    dateOfAcquisition(dateOfAcquisition) {
}
int Product::getAge() const{
    time_t currentTime;
    time(&currentTime);
    double timeDiffInSec = difftime(currentTime, dateOfAcquisition);
    return (int)(timeDiffInSec/(3600*24));
}
int Product::getCurrentPrice() const {
    return initialPrice;
}
void Product::print(std::ostream &os) const {
    os << "Type: " << getType() << ", ";
    os << "Name: " << getName();
    printParams(os);
}
void Product::printParams(std::ostream &os) const {
    char strDateOfAcquisition[9];
    strftime(strDateOfAcquisition, 9, "%Y%m%d",
             gmtime(&dateOfAcquisition));
    os << ", " << "Initial price: " << initialPrice
       << ", " << "Date of acquisition: " << strDateOfAcquisition
       << ", " << "Age: " << getAge()
       << ", " << "Current price: " << getCurrentPrice();
}
void Product::writeParamsToStream(std::ostream &os) const {
    char strDateOfAcquisition[9];
    tm* t = localtime(&dateOfAcquisition);
    strftime(strDateOfAcquisition, 9, "%Y%m%d", t);
    os << " " << name << " " << initialPrice << " " <<strDateOfAcquisition;
}
void Product::loadParamsFromStream(std::istream &is) {
    is >> name;
    is >> initialPrice;
    char buff[9];
    is.width(9);
    is >> buff;
    if (strlen(buff) != 8)
        throw range_error("Invalid time format");
    char workBuff[5];
    tm t;
    int year;
    strncpy(workBuff, buff, 4); workBuff[4] = '\0';
    year = atoi(workBuff); t.tm_year = year - 1900;
    strncpy(workBuff, &buff[4], 2); workBuff[2] = '\0';
    t.tm_mon = atoi(workBuff) - 1;
    strncpy(workBuff, &buff[6], 2); workBuff[2] = '\0';
    t.tm_mday = atoi(workBuff);
    t.tm_hour = t.tm_min = t.tm_sec = 0;
    t.tm_isdst = -1;
    dateOfAcquisition = mktime(&t);
}
std::istream& operator>>(istream& is, Product& product) {
    product.loadParamsFromStream(is);
    return is;
}
std::ostream& operator<<(ostream& os, Product& product) {
    os <<product.getCharCode();
    product.writeParamsToStream(os);
    return os;
}
        ]]></programlisting>
        <para>
           <emphasis role = "strong">Tanulságok, tapasztalatok, magyarázat:</emphasis>
        </para>  
          
        <para>
            Az esettanulmány az UML tervezés előnyeit próbálja megmutatni.  A
            történet, hogy van egy cég, aki számítógépeket és alkatrészeket
            árul, és az ő számukra kell egy alkalmazást készíteni, ami
            nyilvántartja az alkatrészeket és a konfigurációkat.  Továbbá cél
            az is, hogy a jövőben minél egyszerűbben kiegészíthető koncepciót
            alkossunk.
        </para>
        <para>
            A Product osztály az initialPrice, dateOfAcquisition és name tagváltozókkal rendelkezik.
            Mivel ezek protected változók, ezért vannak publikus tagfüggvényeink is: GetInitialPrice, GetDateOfAcquisition, GetName.
            A GetAge tagfüggvény az aktuális dátum és a beszerzési dátum alapján a termék korát adja vissza napokban.
            A típuskód lekérdezésére a GetType és a GetCharCode tagfüggvények szolgálnak.
            A termékek formázott megjelenítését a Print tagfüggvény biztosítja.
            A termékek adatfolyamba írását és onnan történő olvasását támogatja a globális <![CDATA[<<]]> és <![CDATA[>>]]> operátorok megfelelő túlterhelt változatának megírása. 
        </para>
        <para>
            A megoldást esetünkben egy C++ könyvtár (library) segítségével
            oldották meg, hiszen így felhasználható anélkül is, hogy kiadnák a
            forráskódját.
        </para>
        <para>
            Ez a létrehozott keretrendszer képes kezelni elemi, vagy összetett
            termékeket, egyszerűen úgy, hogy a terméket reprezentáló osztályban
            van egy termékeket tároló vektor, ami tartalmazza az ő
            alkatrészeit, amik szintén a termék osztály példányai.
        </para>
        <para>
            Az osztályok UML osztálydiagrammjai szerint a következőképpen
            néz ki:
        </para>
        <figure>
            <title>C++ könyv esettan</title>
            <mediaobject>
                <imageobject>
                    <imagedata fileref="./pictures/bmecpp.png" width="100%" />
                </imageobject>
            </mediaobject>
        </figure>
        <para>
            A program egyszerű felépítésű szövegfájlokból képes beolvasni
            adatokat, és ezeket reprezentálja ebben a bizonyos
            adatszerkezetben, amiről beszéltünk.
        </para>
    </section>
    
    <section>
        
        <title>IV. BPMN</title>
        
        <para>
            Rajzoljunk le egy tevékenységet BPMN-ben!
        </para>
        <para>
            Ehhez a feladathoz kiváló segítséget nyújtott nekem a <link
            xlink:href="https://demo.bpmn.io/new">bpmn.io</link> webapplkáció.
        </para>
        <para>
           <emphasis role = "strong">Tanulságok, tapasztalatok, magyarázat:</emphasis>
        </para>  
         <para>
            Az alábbi BPMN példa azt mutatja be, hogy mi történhet,
            amennyiben <emphasis>éhes vagyok</emphasis>.
        </para>
        <figure>
            <title>BPMN tevékenység</title>
            <mediaobject>
                <imageobject>
                    <imagedata fileref="./pictures/bpmn.png" width="100%" />
                </imageobject>
            </mediaobject>
        </figure>
        <para>
            Az ábrát egyszerűen tudjuk értelmezni, de ehhez nyújtok némi
            segítséget;
        </para>
        <itemizedlist>
            <listitem>
                <para>
                    A vékony körvonalú kör a <emphasis
                    role="strong">tevékenység kezdetét</emphasis> jelöli.
                </para>
            </listitem>
            <listitem>
                <para>
                    A téglalapra hasonlító síkidomok a <emphasis
                    role="strong">feladatok</emphasis>at jelölik.
                </para>
            </listitem>
            <listitem>
                <para>
                    A rombuszba zárt kör egy úgynevezett <emphasis
                    role="strong">kapu</emphasis>. Ez a változat megfelel a
                    <emphasis role="strong">megengedő vagy</emphasis>nak, míg a
                    rombuszba zárt X a kizáró vagy megfelelője.
                </para>
            </listitem>
            <listitem>
                <para>
                   A vastag körvönalú kör a <emphasis
                   role="strong">tevékenység</emphasis> vége.
                </para>
            </listitem>
        </itemizedlist>  
    </section>
    
    <section>
        
        <title>V. TeX UML</title>
                
        <para>
           <emphasis role = "strong">Tanulságok, tapasztalatok, magyarázat:</emphasis>
        </para>  
        
        <note>
            <title>Összevont feladat</title>
            <para>
                Ezt a feladatot összevontam a csokor első feladatával.
            </para>
        </note>
        <para>
            LaTeX-ben például a <filename>tikz-uml</filename> csomaggal
            készíthetünk UML diagrammokat, erről rögtön a csokor első
            feladatában látható is egy példa.
        </para>
         
   </section>
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                        
</chapter>                
