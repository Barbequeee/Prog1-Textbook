<chapter xmlns="http://docbook.org/ns/docbook" xmlns:xlink="http://www.w3.org/1999/xlink" xmlns:xi="http://www.w3.org/2001/XInclude" version="5.0" xml:lang="hu">
    <info>
        <title>Helló, Turing!</title>
        <keywordset>
            <keyword/>
        </keywordset>
    </info>
    <section>
    <title>I. Végtelen ciklus</title>
        
        <para>
            Írj olyan C végtelen ciklusokat, amelyek 0 illetve 100 százalékban dolgoztatnak egy magot és egy olyat, amely  
            100 százalékban minden magot!
        </para>
        <para>
           <emphasis role = "strong">Megoldás:</emphasis>
        </para>
        <para>
                a) 0 százalékban dolgoztatnak egy magot:

                <programlisting language="c"><![CDATA[
                #include <omp.h>

                int main()
                {
                    #pragma omp parallel
                    {
                        for(;;);
                    }
                    return 0;
                }]]>            
            </programlisting>
                b) 100 százalékban dolgoztatnak egy magot:
            <programlisting language="c"><![CDATA[
                #include <stdio.h>

                int main()
                {
                    for (;;)
                        {
                        }
                    return 0;
                }]]>
            </programlisting>
                c) 100 százalékban dolgoztatnak minden magot:
            <programlisting language="c"><![CDATA[    
                #include <unistd.h>
                #include <sys/types.h>

                int main()
                {
                    int mag1, mag2, mag3;
    
                    if(!(mag1 = fork()))
                    {
                        for(;;)
                            {
                            }
                    }
                    if(!(mag2 = fork()))
                    {
                        for(;;)
                            {
                            }
                    }
                    if(!(mag3 = fork()))
                    {
                        for(;;)
                            {
                            }
                    }

                    for(;;)
                        {
                        }
                    return 0;
                }]]>
            </programlisting>    
        </para>
        <para>
           <emphasis role = "strong">Tanulságok, tapasztalatok, magyarázat:</emphasis>
        </para>
        <para>    
            Ahogy a kép is mutatja, az első feladatrészben 0%-ot mutat egy pillanat erejéig a Rendszerfigyelő az opm.h miatt.
            A második feladatrészben már folyamatos a terhelés, és ott csak 1 magot dolgoztat a for-ciklus.
            Az utolsó részben 4 mag miatt 4 for-ciklus szerepel, és így a Rendszerfigyelőben is megtekinthetjük, hogy mindenhol 100%-os lesz a terhelés.
            Végtelen ciklusnak olyan ciklusokat hívunk, melyek általában valamilyen logikai hiba miatt soha nem érnek véget .     
        </para>
        <figure>
			<title>Rendszerfigyelő, ahol 100%-os a terhelés mindenhol</title>
			<mediaobject>
				<imageobject>
					<imagedata fileref="pictures/vegtelen.png" />
				</imageobject>
				
			</mediaobject>
        </figure>            
    </section>        
        
    <section>
        <title>II. Lefagyott, nem fagyott, akkor most mi van?</title>
        <para>
            Mutasd meg, hogy nem lehet olyan programot írni, amely bármely más programról eldönti, hogy le fog-e fagyni vagy sem!
        </para>
        <para>
            Megoldás videó:
        </para>
        <para>
            Megoldás forrása:  tegyük fel, hogy akkora haxorok vagyunk, hogy meg tudjuk írni a <function>Lefagy</function>
            függvényt, amely tetszőleges programról el tudja dönteni, hogy van-e benne vlgtelen ciklus:              
        </para>
        <programlisting language="c"><![CDATA[Program T100
{

	boolean Lefagy(Program P)
	{
		 if(P-ben van végtelen ciklus)
			return true;
		 else
			return false; 
	}

	main(Input Q)
	{
		Lefagy(Q)
	}
}]]></programlisting>            
        <para>
            A program futtatása, például akár az előző <filename>v.c</filename> ilyen pszeudókódjára:
            <screen><![CDATA[T100(t.c.pseudo)
true]]></screen>            
            akár önmagára
            <screen><![CDATA[T100(T100)
false]]></screen>  
            ezt a kimenetet adja.          
        </para>
        <para>
            A T100-as programot felhasználva készítsük most el az alábbi T1000-set, amelyben a
            Lefagy-ra épőlő Lefagy2 már nem tartalmaz feltételezett, csak csak konkrét kódot:
        </para>
        <programlisting language="c"><![CDATA[Program T1000
{
	boolean Lefagy(Program P)
	{
		 if(P-ben van végtelen ciklus)
			return true;
		 else
			return false; 
	}

	boolean Lefagy2(Program P)
	{
		 if(Lefagy(P))
			return true;
		 else
			for(;;); 
	}

	main(Input Q)
	{
		Lefagy2(Q)
	}
}]]></programlisting>           
        <para>
            Mit for kiírni erre a <computeroutput>T1000(T1000)</computeroutput> futtatásra?
                                
            <itemizedlist>
                <listitem>
                    <para>Ha T1000 lefagyó, akkor nem fog lefagyni, kiírja, hogy true</para>                        
                </listitem>
                <listitem>
                    <para>Ha T1000 nem fagyó, akkor pedig le fog fagyni...</para>                        
                </listitem>
            </itemizedlist>
            akkor most hogy fog működni? Sehogy, mert ilyen <function>Lefagy</function>
            függvényt, azaz a T100 program nem is létezik.                
        </para>
        <para>
            <emphasis role = "strong">Tanulságok, tapasztalatok, magyarázat:</emphasis>
        </para>
        <para>
            Elmondhatjuk, hogy szinte egyidős a programozással a lefagyó program problémája. 
            Alan Turing (aki megalkotta a Turing-gép fogalmát) matematikai eszközökkel keresztül 
            bizonyította be, hogy ilyen programot nem lehet írni, míg egyszerű programok esetében 
            ránézésére meg lehet mondani, hogy le fog-e fagyni, bonyolultabb programok esetében ezt 
            eldönteni is nehezebb.
	</para>
	<para>
            Egy ilyen program tömérdek problémát megoldana, tehát amennyiben a bizonyítás ellenére nekünk 
            sikerülne egy ilyen programot írnunk, valószínű, hogy nem kellene dolgoznunk soha életünkben, 
            hiszen hatalmas összeget érne.
        </para>
    </section>        
                
    <section>
        <title>III. Változók értékének felcserélése</title>
        <para>
            Írj olyan C programot, amely felcseréli két változó értékét, bármiféle logikai utasítás vagy kifejezés
            nasználata nélkül!
        </para>
        <para>
            Megoldás videó: <link xlink:href="https://bhaxor.blog.hu/2018/08/28/10_begin_goto_20_avagy_elindulunk">https://bhaxor.blog.hu/2018/08/28/10_begin_goto_20_avagy_elindulunk</link>
        </para>
        <para>
            Megoldás forrása: C 
            <programlisting language="c"><![CDATA[ 
            #include <stdio.h>

            void swap(int *a, int *b)
            {
                    *a -= *b;
                    *b += *a;
                    *a = *b - *a;
            }

            int main()
            {
                    int x = 3, y = 7;

                    printf("x=%d y=%d\n", x, y);
                    swap(&x, &y);
                    printf("x=%d y=%d\n", x, y);

                    return 0;
            }]]></programlisting>
        </para>
        <para>
            <emphasis role="strong">Tanulságok, tapasztalatok, magyarázat:</emphasis>
        </para>
        <para>
            Logikai utasítások nélkül, két változó cseréje például összeadással oldható meg. A fenti 
            programot kipróbálva láthatjuk, hogy a programunk lefordul és működik.
        </para>
        <para>
            SWAP = (csere) A C programozási nyelvbenm a swap segítségével a programunkban nincs szükség egy 
            harmadik változó, XOR operátor vagy pointerek használatára.
        </para>
    </section>                     

    <section>
        <title>IV. Labdapattogás</title>
        <para>
            Először if-ekkel, majd bármiféle logikai utasítás vagy kifejezés
            nasználata nélkül írj egy olyan programot, ami egy labdát pattogtat a karakteres konzolon! (Hogy mit értek
            pattogtatás alatt, alább láthatod a videókon.)
        </para>
        <para>
            Megoldás videó: <link xlink:href="https://bhaxor.blog.hu/2018/08/28/labdapattogas">https://bhaxor.blog.hu/2018/08/28/labdapattogas</link>
        </para>
        <para>
            Megoldás forrása: C
            <programlisting language="c"><![CDATA[
            
            #include <stdio.h>
            #include <stdlib.h>
            #include <curses.h>
            #include <unistd.h>
            #include <sys/ioctl.h>

            int main (void)
            {
                    struct winsize w;
                    int xj = 0, xk = 0, yj = 0, yk = 0;
                    int mx, my;

                    WINDOW *ablak;
                    ablak = initscr ();
                    noecho ();
                    cbreak ();
                    nodelay (ablak, true);

                    for(;;)
                    {
                            ioctl (STDOUT_FILENO, TIOCGWINSZ, &w);
                            mx = w.ws_col * 2, my = w.ws_row * 2;

                            xj = (xj - 1) % mx;
                            xk = (xk + 1) % mx;

                            yj = (yj - 1) % my;
                            yk = (yk + 1) % my;

                            clear ();


                            mvprintw (abs ((yj + (my - yk)) / 2),
                                      abs ((xj + (mx - xk)) / 2), "x");

                            refresh ();
                            usleep(150000);
                    }
                    return 0;
            } ]]></programlisting>
        </para>
        <para>
            <emphasis role = "strong">Tanulságok, tapasztalatok, magyarázat:</emphasis>
        </para>
        <para>
            Futtatás: gcc lab1.c -o lab -lncurses
        </para>
        <para>
                      ./lab
        </para>
        <para>
            Olyan függvényt kell létrehoznunk, amely leírja a labda pattogását, 
            de mégsem vesz fel olyan értékeket, amik kívül esnek a konzolunkon.

            Az xj, xk változók értékét beállítjuk úgy, hogy az a maradéka legyen 
            terminál szélességének a kétszeresének a hányadosával.

            Ugyanezt elvégezzük az Y tengelyen is.

            Majd a képernyőt letöröljük, hogy ne maradjon fent a labdánk az előző 
            kirajzolásból adódóan. Ezzel készülünk fel a következő képkocka megjelenítésére.

            Mindezek után rajzoljuk ki magát a labdát, és meghívjuk az <code>mvprintw</code> függvényt. 
            Ez a függvény kiírat egy karaktert a megadott x és y koordinátáknak megfelelően a képernyőn 
            valahol.

            A refresh függvény azért szükséges, hogy kimenetet lássunk a terminál ablakunkban,
            majd váruk 150000 mikroszekundumnyi időt.
        </para>
        
    </section>                     

    <section>
        <title>V. Szóhossz és a Linus Torvalds féle BogoMIPS</title>
        <para>
            Írj egy programot, ami megnézi, hogy hány bites a szó a gépeden, azaz mekkora az <type>int</type> mérete.
            Használd ugyanazt a while ciklus fejet, amit Linus Torvalds a BogoMIPS rutinjában! 
        </para>
       
        <para>
            Megoldás forrása: C++
        </para>
        <para>
            <programlisting> language="c++"<![CDATA[
            #include <stdio.h> 
            int			
            main (void)		
            {
              int h = 0;		
              int n = 0x01;	
              do			
                ++h;
              while (n <<= 1);	
              printf ("A szohossz ezen a gepen: %d bites\n", h);	
              return 0;
            }
            ]]></programlisting>        
        </para>
        <para>
            <emphasis role = "strong">Tanulságok, tapasztalatok, magyarázat:</emphasis> 
        </para>
        <para>
            Az adott gépen hány bites a szóhossz: 
			A szóhossz megállapítására használhatunk egy <code language="c">int</code> típusú változót, melyet
			inicializálunk <code>1</code>-el, majd addig shifteljük balra, amíg csak tudjuk. Ha megszámoljuk,
			hogy hányszor tudtuk balra shiftelni, megkapjuk a szóhosszt az adott számítógépen.
        </para>
    </section>                     

    <section>
        <title>VI. Helló, Google!</title>
        <para>
            Írj olyan C programot, amely egy 4 honlapból álló hálózatra kiszámolja a négy lap Page-Rank 
            értékét!
        </para>
        <para>
            Megoldás forrása: C++
        </para>
        <para>
            <programlisting language="c++"><![CDATA[
            #include <stdio.h>
            #include <math.h>

            void
            kiir (double tomb[], int db){
                for (int i = 0; i < db; i++){
                printf("PageRank [%d]: %lf\n", i, tomb[i]);
                }
            }

            //using namespace math;
            double
            tavolsag (double PR[], double PRv[], int n){

                double osszeg = 0.0;

                for (int i = 0; i < n; ++i){
                    osszeg += (PRv[i] - PR[i]) * (PRv[i] - PR[i]);
                }
                return sqrt (osszeg);
            }

            int
            main (void){
                double L [4][4] = {
                    {0.0, 0.0, 1.0 / 3.0, 0.0},
                    {1.0, 1.0 / 2.0, 1.0 / 3.0, 1.0},
                    {0.0, 1.0 / 2.0, 0.0, 0.0},
                    {0.0, 0.0, 1.0 / 3.0, 0.0}
                    };

            double PR[4] = { 0.0, 0.0, 0.0, 0.0 };
            double PRv[4] = {1.0 / 4.0, 1.0 / 4.0, 1.0 / 4.0, 1.0 / 4.0 };

            int i, j;

            for (;;){

                for(i=0;i<4;++i){
                    PR[i] = 0.0;
                    for (j=0;j<4;++j){
                        PR[i] += (L[i][j] * PRv[j]);
                            }
                        }

                if (tavolsag ( PR, PRv, 4) < 0.0000000001)
                    break;

                for (i = 0; i < 4; ++i)
                    PRv[i] = PR[i];

                }

            kiir (PR, 4);

            return 0;
            }
            ]]></programlisting>   
        </para>
        <para>
            <emphasis role = "strong">Tanulságok, tapasztalatok, magyarázat:</emphasis>
        </para>
        <para>
            Kapott értékek: PageRank [0]: 0.090909 PageRank [1]: 0.545455 PageRank [2]: 0.272727 PageRank [3]: 0.090909
        </para>
        <para>
            Ezt az algoritmust Larry Page (innen a neve; PageRank) és Sergey Brin fejlesztette 
            ki a Googlenél .
            Azt fedezték fel, hogy minél több oldal mutat egy oldalra, annak az oldalnak az értéke annál 
            nagyobb. Egy oldal fontossága az alapján dől el, hogy hány másik oldal mutat ő rá.
        </para>
        <para>
            A Googlenél ennek az algoritmusnak egy eléggé módosított változata fut, mely nem is publikus, 
            hiszen akkor mindenki kereső szolgáltatást indíthatna.
            A fent látott példa az algoritmus egyszerűsített változata, miszerint ez már magában hordoz 
            némi hibákat, és  eltérést. Például a "zsákutca" hiba, amely szerint zsákutcába érkezünk, 
            amennyiben olyan oldalt találunk, amely nem mutat egy másikra.
        </para>
    </section>

    <section>
        <title>VII. 100 éves a Brun tétel</title>
        <para>
            Írj R szimulációt a Brun tétel demonstrálására!
        </para>
        <para>
            <programlisting><![CDATA[
            library(matlab)

            stp <- function(x){

                primes = primes(x)
                diff = primes[2:length(primes)]-primes[1:length(primes)-1]
                idx = which(diff==2)
                t1primes = primes[idx]
                t2primes = primes[idx]+2
                rt1plust2 = 1/t1primes+1/t2primes
                return(sum(rt1plust2))
            }

            x=seq(13, 1000000, by=10000)
            y=sapply(x, FUN = stp)
            plot(x,y,type="b")

            ]]></programlisting>
        </para>
        <para>
            Megoldás videó: <link xlink:href="https://youtu.be/xbYhp9G6VqQ">https://youtu.be/xbYhp9G6VqQ</link>
        </para>
        <para>
            Megoldás forrása: <link xlink:href="https://gitlab.com/nbatfai/bhax/blob/master/attention_raising/Primek_R">https://gitlab.com/nbatfai/bhax/blob/master/attention_raising/Primek_R</link>
        </para>
        <para>
            <emphasis role = "strong">A Brun tétel jelentése:</emphasis>
        </para>
 
            <para>
		A prímszámok olyan számok, melyek csak önmagukkal és eggyel osztva nem adnak maradékot.
		Az ikerprímek pedig olyan príszmámok, melyek különbsége kettő.
            </para>
            <para>
		A Brun tétel azt mondja ki, hogy ha vesszük az ikerprímek reciprokát, majd elkezdjük összeadni őket, pl.
		<inlineequation>
                    <alt role="tex">\left(\frac{1}{3} + \frac{1}{5}\right) + \left(\frac{1}{5} + \frac{1}{7}\right) + ...</alt>
			<mathphrase>
			</mathphrase>
		</inlineequation>,
		akkor ez a sor egy B<subscript>2</subscript> (Brun-)konstanshoz fog konvergálni.
		Ez a felfedezés viszont nem oldja meg az ikerprímek számának problémáját, hiszen arról nem nyilatkozik,
		hogy a sor véges, vagy végtelen.
            </para>
            <para>
		Ez a program az ikerprímeket ábrázolja egy koordináta rendszerben, melyen jól megfigyelhető hogy valóban
		a B<subscript>2</subscript> konstanshoz tartunk.
            </para>
            <figure>
		<title>A B<subscript>2</subscript> konstans közelítése</title>
                    <mediaobject>
			<imageobject>
                            <imagedata fileref="pictures/brun.png" width="50%"/>
			</imageobject>
			<textobject>
				<phrase>A B<subscript>2</subscript> konstans közelítése</phrase>
			</textobject>
                    </mediaobject>
            </figure>
    </section>
    
    <section>
        <title>VIII. A Monty Hall probléma</title>
        <para>
            Írj R szimulációt a Monty Hall problémára!
        </para>
        <para>
            <programlisting><![CDATA[
            kiserletek_szama=10000000
            kiserlet = sample(1:3, kiserletek_szama, replace=T)
            jatekos = sample(1:3, kiserletek_szama, replace=T)
            musorvezeto=vector(length = kiserletek_szama)

            for (i in 1:kiserletek_szama) {

                if(kiserlet[i]==jatekos[i]){

                    mibol=setdiff(c(1,2,3), kiserlet[i])

                }else{

                    mibol=setdiff(c(1,2,3), c(kiserlet[i], jatekos[i]))

                }

                musorvezeto[i] = mibol[sample(1:length(mibol),1)]

            }

            nemvaltoztatesnyer= which(kiserlet==jatekos)
            valtoztat=vector(length = kiserletek_szama)

            for (i in 1:kiserletek_szama) {

                holvalt = setdiff(c(1,2,3), c(musorvezeto[i], jatekos[i]))
                valtoztat[i] = holvalt[sample(1:length(holvalt),1)]

            }

            valtoztatesnyer = which(kiserlet==valtoztat)


            sprintf("Kiserletek szama: %i", kiserletek_szama)
            length(nemvaltoztatesnyer)
            length(valtoztatesnyer)
            length(nemvaltoztatesnyer)/length(valtoztatesnyer)
            length(nemvaltoztatesnyer)+length(valtoztatesnyer)

                
            ]]></programlisting>
        </para>
        <para>
            Megoldás videó: <link xlink:href="https://bhaxor.blog.hu/2019/01/03/erdos_pal_mit_keresett_a_nagykonyvben_a_monty_hall-paradoxon_kapcsan">https://bhaxor.blog.hu/2019/01/03/erdos_pal_mit_keresett_a_nagykonyvben_a_monty_hall-paradoxon_kapcsan</link>
        </para>
        <para>
            Megoldás forrása: <link xlink:href="https://gitlab.com/nbatfai/bhax/tree/master/attention_raising/MontyHall_R">https://gitlab.com/nbatfai/bhax/tree/master/attention_raising/MontyHall_R</link>
        </para>
        <para>
            <emphasis role = "strong">Tanulságok, tapasztalatok, magyarázat:</emphasis>
        </para>
        <para>
            Az R programozási nyelv, egy statisztikai számításokra alkalmas, interpreteres nyelv. 
            Ennek köszönhetően a Monthy Hall problémára alkotott R program forrása könnyen olvasható 
            és értelmezhető.
	</para>
	<para>
            A Monty Hall probléma egy TV showból ered, melyben három ajtó közül kell választanunk és az 
            egyik kinyitásával megtalálhatjuk a kincset, a másik kettővel pedig nem. Itt a szimulációban 
            azt vizsgáljuk, hogy érdemes-e váltogatni, hogy mikor melyik ajtót nyitjuk ki, vagy érdemesebb 
            ugyanannál az ajtónál maradni a játék körei során.
	</para>
	<screen>
            <![CDATA[$ Rscript montyhall.r
            [1] "Kiserletek szama: 10000000"
            [1] 3330958
            [1] 6669042
            [1] 0.4994657
            [1] 10000000]]>
        </screen>
	<para>
            A program kimenetét elemezve azt láthatjuk, hogy 100000000 iteráció (= ismétlési szerkezet, ciklus) 
            után az eredmény az, hogy mindenképp érdemes váltogatni az ajtóinkat, ugyanis így megközelítőleg 50 
            százalékos javulást érhetünk el.
            A 3330958 pedig azt mutatja, hogy az összes esetből ennyiszer nyerünk úgy, ha nem változtatunk 
            az ajtónkon, amin benyitunk. A 6669042 pedig a nyertes esetek száma. A 0.4994657 mutatja meg az 
            előbbi kettőnek a hányadosát.
        </para>           
    </section>

</chapter>