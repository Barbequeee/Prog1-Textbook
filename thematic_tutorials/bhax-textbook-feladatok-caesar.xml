<chapter xmlns="http://docbook.org/ns/docbook" xmlns:xlink="http://www.w3.org/1999/xlink" xmlns:xi="http://www.w3.org/2001/XInclude" version="5.0" xml:lang="hu">
    <info>
        <title>Helló, Caesar!</title>
        <keywordset>
            <keyword/>
        </keywordset>
    </info>
    <section>
       <title>I. <type>double **</type> háromszögmátrix</title>
       
        <para>
            Forráskód:
        </para>
        <programlisting>
            <![CDATA[
            #include <stdio.h>
            #include <stdlib.h>		// malloc()
            int main(void)
            {
                    const int db = 5;

                    double **hm;
                    printf("Mutato cime: %p\n", &hm);

                    hm = (double **)malloc(db * sizeof(double));
                    printf("Sorok tombjenek cime: %p\n", hm);

                    for (int i = 0; i < db; i++)
                            hm[i] = (double *)malloc(db * sizeof(double));
                    printf("Elso sor cime: %p\n", hm[0]);

                    for (int i = 0; i < db; i++) {
                            printf("|");
                            for (int j = 0; j < db; j++) {
                                    hm[i][j] = (i + 1) / (j + 1);
                                    printf("%.2f  ", hm[i][j]);
                            }
                            printf("|\n");
                    }

                    return 0;
            }
            ]]>
        </programlisting>
        <para>
           <emphasis role = "strong">Tanulságok, tapasztalatok, magyarázat:</emphasis>
        </para> 
        <para>
            A C nyelv fő jellegzetességével, a dinamikus memóriakezeléssel foglalkozunk ebben a feladatban.
            Nézzünk meg egy olyan példát, ahol létrehozunk egy double ** háromszögmátrixot, ami lényegében 
            nem más, mint egy két dimenziós tömb. Nem mondjuk meg előre, hogy hány elemű tömbjeink lesznek, 
            hanem azokat majd dinamikusan foglaljuk le.
	</para>
        <para>
            A program úgy működik, hogy elsőnek megadjuk, hogy hányszor hányas tömböt szeretnénk létrehozni, 
            majd eltároljuk a DB változóba. Ezután lefoglaljuk magát a HM háromszögmátrixot, és a megértés 
            érdekében kiíratjuk a memória címét is. Ezt követően lefoglalunk <code>db</code> darab 
            (esetünkben 5) tömböt (ezek lesznek a sorok), amelyek a következő lépésben szintén tartalmazni 
            fognak 5 db tömböt (oszlopok).
	</para>

	<para>
            A programunk egy kvadratikus háromszögmátrixot készít el, olyan módon, hogy minden elemét úgy 
            állítjuk be, hogy <code>(i+1)/(j+1)</code>, ahol az i a sor	száma, a j pedig az oszlop száma. 
            A +1 azért kell, hogy ne osszunk nullával véletlenül se. Egy alsó háromszögmátrix egy olyan 
            mátrix, melyben a főátló felett csupán nullák vannak. 
	</para>

		<screen>
<![CDATA[
Mutato cime: 0x7fffbc435de0
Sorok tombjenek cime: 0x5567bca69670
Elso sor cime: 0x5567bca696a0
|1.00  0.00  0.00  0.00  0.00  |
|2.00  1.00  0.00  0.00  0.00  |
|3.00  1.00  1.00  0.00  0.00  |
|4.00  2.00  1.00  1.00  0.00  |
|5.00  2.00  1.00  1.00  1.00  |]]>
		</screen>

	<para>
            TANULSÁG: hogy a [] jelek valóban csak a fordító adta kényelmi funkció. A C programozási 
            nyelvben azt a kifejezést, hogy <code language="c">hm[1][1]</code> legalább háromféleképpen
            fejezhetjük ki, melyek a következők: <code language="c">(*hm[1]+1)</code>, vagy
            <code language="c">(*(*hm + 1)+1)</code>.
        </para>           
    </section>        
    <section>
        <title>II. C EXOR titkosító</title>
        <para>
            Írj egy EXOR titkosítót C-ben!
        </para>
        <para>
            Forráskód:                
        </para>
        <programlisting>
<![CDATA[
    #define MAX_KEY_SIZE 100
    #define BUFFER_SIZE 256

    char key[MAX_KEY_SIZE];
    char buffer[BUFFER_SIZE];

    int key_index = 0, read_bytes = 0;
    int key_size = strlen(argv[1]);

    strncpy(key, argv[1], MAX_KEY_SIZE);

    while ((read_bytes = read(0, (void *)buffer, BUFFER_SIZE))) {
        for (int i = 0; i < read_bytes; i++) {
            buffer[i] ^= key[key_index];
            key_index = (key_index + 1) % key_size;
        }

    write(1, buffer, read_bytes);
    }]]>
        </programlisting>
        <para>
           <emphasis role = "strong">Tanulságok, tapasztalatok, magyarázat:</emphasis>
        </para>
        <para>
        	Az XOR titkosító program egyszerűen működik. Az
			argumentumból kiolvassuk a kulcsot majd a <code>while</code>
			ciklusban olvassuk az érkező bementet az úgynevezett
			standard inputon. Ezután megnézzük a bemenetünk méretét,
			és ennek a teljes tartalmát "titkosítjuk", azaz
			elvégezzük rajta a bitenkénti XOR utasítást.
			Majd vesszük a buffert és kinyomjuk az úgynevezett
			standard outputon. Hasznos ez a része, mert a felhasználó
			egyszerűen megfigyelheti, vagy fájlba írhatja a kimenetet.
                        Természetesen ugyanezzel a kóddal és a kulcs ismeretében,
			a generált titkosított állomány vissza is fejthető.
	</para>
            
    </section>        
    <section>
        <title>III. Java EXOR titkosító</title>
        <para>
            Írj egy EXOR titkosítót Java-ban!
        </para>
        <para>
            Forráskód:               
        </para>
        <programlisting>
<![CDATA[import java.util.*;

class XorEncode {
    public static void main(String[] args) {
        String kulcs = "";

            if(args.length > 0) {
                kulcs = args[0];
            } else {
                System.out.println("Kulcs nelkul nem titkositok!");
                System.out.println("Hasznalat: java XorEncode.java [kulcs]");
                System.exit(-1);
            }

            Scanner sc = new Scanner(System.in);
        String str = "";

            while(sc.hasNext()) {
                str = sc.next();
                System.out.println(xor(kulcs, str));
            }
    }

    public static String xor(String kulcs, String s) {
        StringBuilder sb = new StringBuilder();

            for(int i = 0; i < s.length(); i++) {
                sb.append((char)(s.charAt(i) ^ kulcs.charAt(i % kulcs.length())));
            }

            return sb.toString();
        }
    }]]></programlisting>
        <para>
           <emphasis role = "strong">Tanulságok, tapasztalatok, magyarázat:</emphasis>
        </para>            
        <para>
			A Java egy objektum orientált programozási nyelv, melyet főleg vállalati
			környezetekben használnak, mert nincs benne semmiféle memóriakezelés, és jellegénél fogva jól modulálható.
			Sokan emiatt hívják
			viccesen memóriakezelés nélküli C programozási nyelvnek is, mely érthető,
			hiszen a két nyelv szintaxisa között valóban vannak hasonlóságok.
	</para>
	<para>
			Hasonlóan járunk el ebben a programban is, mint a C-ben.
			Az argumentumok közül kiolvassuk a kulcsot, majd a standard inputon
			megjelenő szöveget XOR-ozzuk ezzel a kulccsal, majd a kimeneten
			kiíratjuk a végeredményt.
        </para>
    </section>        
    <section>
        <title>IV. C EXOR törő</title>
        <para>
            Írj egy olyan C programot, amely megtöri az első feladatban előállított titkos szövegeket!
        </para>

        <para>
            Megoldás videó:
        </para>
        <para>
            Forráskód:              
        </para>
        <programlisting><![CDATA[
                  #define MAX_TITKOS 4096
#define OLVASAS_BUFFER 256
#define KULCS_MERET 8
#define _GNU_SOURCE

#include <stdio.h>
#include <unistd.h>
#include <string.h>
#include <stdlib.h>

double atlagos_szohossz(const char *titkos, int titkos_meret);
int tiszta_lehet(const char *titkos, int titkos_meret);
void exor(const char kulcs[], int kulcs_meret, char titkos[],
	  int titkos_meret, char *buffer);
void exor_tores(const char kulcs[], int kulcs_meret, char titkos[],
		int titkos_meret);

int main(void)
{
	char titkos[MAX_TITKOS];
	char *p = titkos;
	char *kulcs;

	// titkos fajt berantasa
	int olvasott_bajtok;
	while ((olvasott_bajtok =
		read(0, (void *)p,
		     (p - titkos + OLVASAS_BUFFER <
		      MAX_TITKOS) ? OLVASAS_BUFFER : titkos +
		     MAX_TITKOS - p)))
		p += olvasott_bajtok;

	// maradek hely nullazasa a titkos bufferben
	for (int i = 0; i < MAX_TITKOS - (p - titkos); ++i)
		titkos[p - titkos + i] = '\0';

	int ii, ki, ji, li, mi, ni, oi, pi;

#pragma omp parallel for private(kulcs, ii, ki, ji, li, mi, ni, oi, pi) shared(p, titkos)
	// osszes kulcs eloallitasa
	for (ii = '0'; ii <= '9'; ++ii)
		for (ji = '0'; ji <= '9'; ++ji)
			for (ki = '0'; ki <= '9'; ++ki)
				for (li = '0'; li <= '9'; ++li)
					for (mi = '0'; mi <= '9';
					     ++mi)
						for (ni = '0';
						     ni <= '9'; ++ni)
							for (oi = '0';
							     oi <=
							     '9';
							     ++oi)
								for (pi = '0'; pi <= '9'; ++pi) {
									if ((kulcs = (char *)malloc(sizeof(char) * KULCS_MERET)) == NULL) {
										printf
										    ("Memoria (kulcs) faliora\n");
										exit(-1);
									}

									kulcs
									    [0]
									    =
									    ii;
									kulcs
									    [1]
									    =
									    ji;
									kulcs
									    [2]
									    =
									    ki;
									kulcs
									    [3]
									    =
									    li;
									kulcs
									    [4]
									    =
									    mi;
									kulcs
									    [5]
									    =
									    ni;
									kulcs
									    [6]
									    =
									    oi;
									kulcs
									    [7]
									    =
									    pi;

									exor_tores
									    (kulcs,
									     KULCS_MERET,
									     titkos,
									     p
									     -
									     titkos);
								}

	return 0;
}

double atlagos_szohossz(const char *titkos, int titkos_meret)
{
	int sz = 0;
	for (int i = 0; i < titkos_meret; ++i) {
		if (titkos[i] == ' ') {
			++sz;
		}
	}
	return (double)titkos_meret / sz;
}

int tiszta_lehet(const char *titkos, int titkos_meret)
{
	// a tiszta szoveg valszeg tartalmazza a gyakori magyar szavakat
	// illetve az átlagos szóhossz vizsgálatával csökkentjük a
	// potenciális töréseket

	double szohossz = atlagos_szohossz(titkos, titkos_meret);
	return szohossz > 3.0 && szohossz < 9.0
	    && strcasestr(titkos, "hogy") && strcasestr(titkos, "nem")
	    && strcasestr(titkos, "ne")
	    && strcasestr(titkos, "az") && strcasestr(titkos, "ha");
}
void exor(const char kulcs[], int kulcs_meret, char titkos[],
	  int titkos_meret, char *buffer)
{
	int kulcs_index = 0;
	for (int i = 0; i < titkos_meret; ++i) {
		buffer[i] = titkos[i] ^ kulcs[kulcs_index];
		kulcs_index = (kulcs_index + 1) % kulcs_meret;
	}
}

void exor_tores(const char kulcs[], int kulcs_meret, char titkos[],
		int titkos_meret)
{
	char *buffer;
	if ((buffer =
	     (char *)malloc(sizeof(char) * titkos_meret)) == NULL) {
		printf("Memoria (buffer) faliora\n");
		exit(-1);
	}
	exor(kulcs, kulcs_meret, titkos, titkos_meret, buffer);

	if (tiszta_lehet(buffer, titkos_meret)) {
		printf
		    ("Kulcs: [%c%c%c%c%c%c%c%c]\nTiszta szoveg: [%s]\n",
		     kulcs[0], kulcs[1], kulcs[2], kulcs[3], kulcs[4],
		     kulcs[5], kulcs[6], kulcs[7], buffer);
	}
	free(buffer);
}]]></programlisting>
        <para>
           <emphasis role = "strong">Tanulságok, tapasztalatok, magyarázat:</emphasis>
        </para>
        <para>
            Ez a program csak olyan állományok feltörésére alkalmas,
            amelyeknek a kulcsa csak számokból áll, és 8 karakter
            hosszú. Ezt természetesen a kódban lehet módosítani.
	</para>
	<para>
            A programunk egy Brute force algoritmust használ, hogy visszafejtse
            a titkosított szöveget. A bemenetet olvasva a program
            meghatározza a szavak hosszát, és amennyiben ez megfelel egy
            bizonyos értékhatárnak, megnézi, hogy előfordulnak-e benne
            a leggyakoribb magyar szavak (
	<emphasis>a, van, volt, meg, vagy, már...</emphasis>),
            és ha sikerül találni ilyeneket, akkor kiírja az outputra.
        </para>
        <para>
            Brute Force algoritmus:
        </para>
        <para>
            A legegyszerűbb módszer esetén az adott mintát - mint egy sablont - végigvezetjük a 
            szövegen, s ellenőrizzük, hogy a minta jelei megegyeznek-e a szöveg megfelelő jeleivel. 
        </para>
		          
    </section>        
    <section>
        <title>V. Neurális OR, AND és EXOR kapu</title>

        <para>
            Megoldás videó: <link xlink:href="https://youtu.be/Koyw6IH5ScQ">https://youtu.be/Koyw6IH5ScQ</link>
        </para>
        <para>
            Megoldás forrása: <link xlink:href="https://gitlab.com/nbatfai/bhax/tree/master/attention_raising/NN_R">https://gitlab.com/nbatfai/bhax/tree/master/attention_raising/NN_R</link>               
        </para>
        <para>
           <emphasis role = "strong">Tanulságok, tapasztalatok, magyarázat:</emphasis>
        </para>  
            <para>
			Ebben az R programban egy neurális hálót építünk fel.
			A programot futtatva a program kimenetét vizualizálva kapjuk,
			melyeket alább beágyozva láthat az olvasó is. 
		</para>
		<figure>
			<title>Neurális OR kapu</title>
			<mediaobject>
				<imageobject>
					<imagedata fileref="./pictures/Rplots.png" width="25%"/>
				</imageobject>
			</mediaobject>
		</figure>

		<para>
			149 lépés alatt
			0.000001 hibával sikerült megtanítani a neurális
			hálónkat az OR utasítás elvégzésére.
		</para>

		<figure>
			<title>Neurális OR, AND kapu</title>
			<mediaobject>
				<imageobject>
					<imagedata fileref="./pictures/Rplots1.png" width="25%"/>
				</imageobject>
			</mediaobject>
		</figure>

		<para>
			Az OR és AND
			megtanulásához már 359 lépés kellett.
		</para>

		<figure>
			<title>Neurális EXOR kapu</title>
			<mediaobject>
				<imageobject>
					<imagedata fileref="./pictures/Rplots2.png" width="25%"/>
				</imageobject>
			</mediaobject>
		</figure>

		<para>
			Az EXOR megtanulásához 94 lépés volt elegendő.
		</para>

		<figure>
			<title>Neurális valami kapu</title>
			<mediaobject>
				<imageobject>
					<imagedata fileref="./pictures/Rplots3.png" width="25%"/>
				</imageobject>
			</mediaobject>
		</figure>

		<para>
			A(z) [........] megtanulásához esetünkben 123 lépés volt szükséges.
        </para>          
    </section>        
    <section>
        <title>VI. Hiba-visszaterjesztéses perceptron</title>
        <para>
            C++
        </para>
        <para>
            Forráskód:
        </para>
        <programlisting language = "c++"><![CDATA[
#include "ml.hpp"

#include <iostream>
#include <png++/png.hpp>

int main(int argc, char **argv) {
	png::image<png::rgb_pixel> image(argv[1]);

	int size = image.get_width() * image.get_height();

	Perceptron *p = new Perceptron(3, size, 256, 1);

	double *image_d = new double[size];

	for(int i = 0; i < image.get_width(); i++)
		for(int j = 0; j < image.get_height(); j++)
			image_d[i*image.get_width() + j] = image[i][j].red;

	double value = (*p)(image_d);

	std::cout << value << std::endl;

	delete p;
	delete[] image_d;

	return 0;
}]]>
        </programlisting>
        <para>
           <emphasis role = "strong">Tanulságok, tapasztalatok, magyarázat:</emphasis>
        </para>
        <figure>
			<title>Hiba-visszaterjesztés</title>
            <mediaobject>
                <imageobject>
                    <imagedata fileref="./pictures/hiba_visszaterjesztes.png" width="75%"/>
                </imageobject>
            </mediaobject>
        </figure>
        <para>
            A hibavisszaterjesztéses algoritmusnak számos változatát dolgozták ki. 
            A Perceptron osztályt egy viszonylag egyszerű program keretében használjuk jelenleg. 
            Ez a program mindössze annyit csinál, hogy a bemenetén érkező képnek végigmegy az összes
            pixelén, és számolja a piros színkomponenst.
        </para>
        <para>
            Létrehoztunk egy makefilet, ami a tesztünket is lefuttatja, végül csak az eredményt adja 
            vissza. Tehát megadja, hogy a piros színkomponens jelenléte hány %-ban van jelen az egész 
            képben.
        </para>       
            
    </section>                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                      
</chapter>