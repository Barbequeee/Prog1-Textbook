<chapter xmlns="http://docbook.org/ns/docbook" xmlns:xlink="http://www.w3.org/1999/xlink" xmlns:xi="http://www.w3.org/2001/XInclude" version="5.0" xml:lang="hu">
    <info>
        <title>Helló, Chomsky!</title>
        <keywordset>
            <keyword/>
        </keywordset>
    </info>
    <section>
        <title>I. Decimálisból unárisba átváltó Turing gép</title>
        <para>
            Állapotátmenet gráfjával megadva írd meg ezt a gépet!
        </para>
        <para>
            Megoldás forráskódja:
        </para>
        <para>
            <programlisting language = "c">
    <![CDATA[#include <stdio.h>

    int main(void)
    {
      printf
     ("Írj be egy decimális számot, amelyet unárisba szeretnél konvertálni: ");
        unsigned int in = 0;
        scanf("%d", &in);

        for (int i = 0; i < in; ++i)
            printf((i % 5) ? "|" : " |");

        printf("\n");

        return 0;
    }
            ]]></programlisting>
        </para>
        <para>
             <emphasis role = "strong">Tanulságok, tapasztalatok, magyarázat:</emphasis>  
        </para>
        <para>
            Az unáris számrendszer egy olyan egyszerű számrendszer, ahol vonalakkal, húzásokkal ábrázoljuk a számokat. Egy vonal egyet jelent, és összeadva kell értelmezni ezeket (pl. <code>||| = 3</code>). Ez a Turing-gép ezt
                    az átváltást végzi el.
        </para>
    <screen>
    <![CDATA[$ ./a.out
    Írj be egy decimális számot, amelyet unárisba szeretnél konvertálni: 30
    ||||| ||||| ||||| ||||| ||||| |||||
    $ ./a.out
    Írj be egy decimális számot, amelyet unárisba szeretnél konvertálni: 53
    ||||| ||||| ||||| ||||| ||||| ||||| ||||| ||||| ||||| ||||| |||]]>
    </screen>
    </section>        
        
    <section>
        <title>II. Az a<superscript>n</superscript>b<superscript>n</superscript>c<superscript>n</superscript> nyelv nem környezetfüggetlen</title>
        <para>
            Mutass be legalább két környezetfüggő generatív grammatikát, amely ezt a nyelvet generálja!
        </para>
        <para>
            <emphasis role = "strong">Tanulságok, tapasztalatok, magyarázat:</emphasis>
        </para>
        <orderedlist numeration="upperroman">
            <listitem>
                <para>
                    Legyenek <emphasis>S, X, Y</emphasis> változók.
                    Legyen <emphasis>a, b, c</emphasis> konstansok.
		</para>
		<para>
                    <emphasis>S -> abc, S->aXbc, Xb -> bX, Xc -> Ybcc, bY -> Yb, Ay > aax, Ay -> aa</emphasis>
		</para>
		<screen>
                <![CDATA[S
                aXbc
                abXc (Xc -> Ybcc)
                abYbcc]]>
		</screen>
		<itemizedlist>
                    <listitem><para>S <code>(S->aXbc)</code></para></listitem>
                    <listitem><para>aXbc <code>(Xb->bX)</code></para></listitem>
                    <listitem><para>abXc <code>(Xc->Ybcc)</code></para></listitem>
                    <listitem><para>abYbcc <code>(bY->Yb)</code></para></listitem>
                    <listitem><para>aYbbcc <code>(aY->aa)</code></para></listitem>
                    <listitem><para>aabbcc</para></listitem>
		</itemizedlist>
            </listitem>

            <listitem>
		<para>
                    Legyenek <emphasis>S, X, Y</emphasis> változók.
                    Legyen <emphasis>a, b, c</emphasis> konstansok.
		</para>
		<para>
                    <emphasis>A -> aAB, A -> aC, CB -> bCc, cB -> Bc, C -> bc</emphasis>
		</para>
		<itemizedlist>
                    <listitem><para>A <code>(A->aAB)</code></para></listitem>
                    <listitem><para>aAB <code>(A->aC)</code></para></listitem>
                    <listitem><para>aaCB <code>(CB->bCc)</code></para></listitem>
                    <listitem><para>aaabCc <code>(C->bc)</code></para></listitem>
                    <listitem><para>aabbcc</para></listitem>
		</itemizedlist>
            </listitem>
	</orderedlist>

        <para>
            Noam Chomsky az 50-es években élt és alkotott, nyelvészként végzett.
	</para>
	<para>
            Chomsky a Chomsky-féle nyelvosztályok megalkotója. A fent látottak pedig
            bizonyítékok arra, hogy az
            a<superscript>n</superscript>b<superscript>n</superscript>c<superscript>n</superscript>
            nyelv nem környezetfüggetlen, hiszen kettő nyelvtant is megadtunk, amik
            ezt a nyelvet generálják (valamint példákat rájuk).
        </para>
        <para>
            Ebben a feladatban Az informatika számítástudományi alapjai tantárgyból szerzett 
            tapasztalataimat alkalmaztam.
        </para>
    </section>        
                
    <section>
        <title>III. Hivatkozási nyelv</title>
        <para>
            A <citation>KERNIGHANRITCHIE</citation> könyv C referencia-kézikönyv/Utasítások melléklete alapján definiáld 
            BNF-ben a C utasítás fogalmát!
            Majd mutass be olyan kódcsipeteket, amelyek adott szabvánnyal nem fordulnak (például C89), mással (például C99) igen.
        </para>
        <para>
            Megoldás forrása:
        </para>
        <para>
            Előfordul olyan kódcsipet, mely az egyik C verzióval hibátlanul lefordul,
            míg más C verzió fordítója hibát dob rá.
            Nézzünk meg erre egy konkrét példát, ahol a csipetünk C99-el fordul,
            azonban C89-el nem.
	</para>
        
        <para> 
            C89:
        </para>
        <para> 
            <programlisting><![CDATA[
            int main()
                {
                    int a = 10 /*ez lefordul -std=c89-el*/
                    return 0;
                }
            ]]></programlisting>
        </para>
        <para> 
            C99:
        </para>
        <para> 
            <programlisting><![CDATA[
             int main()
                    {
                        int a = 10; //C99-ben ezt szabad
                        return 0;
                    }
            ]]></programlisting>
        </para>
        <para>
             <emphasis role = "strong">Tanulságok, tapasztalatok, magyarázat:</emphasis>
        </para>
        <para>
	</para>


		<programlisting>
			<![CDATA[
utasítás ::=
	címkézett_utasítás
	| kifejezésutasítás
	| összetett_utasítás
	| kiválasztó_utasítás
	| iterációs_utasítás
	| vezérlésátadó_utasítás
címkézett_utasítás ::=
	azonosító : utasítás
	case állandó_kifejezés : utasítás
	default : utasítás
kifejezésutasítás ::= kifejezés ;
összetett_utasítás ::= { deklarációs_lista  utasítás_lista }
deklarációs_lista ::= deklaráció | deklarációs_lista deklaráció
utasítás_lista ::= utasítás | utasítás_lista utasítás
kiválasztó_utasítás ::=
	if ( kifejezés ) utasítás
	| if ( kifejezés ) utasítás else utasítás
	| switch ( kifejezés ) utasítás
iterációs_utasítás ::=
	while ( kifejezés ) utasítás
	| do utasítás while ( kifejezés ) ;
	| for ( kifejezés ; kifejezés ; kifejezés ) utasítás
vezérlésátadó_utasítás ::=
	goto azonosító ;
	| continue ;
	| break ;
	| return kifejezés ;]]>
		</programlisting>
        <para>
            A C programozási nyelvben az utasítás fogalmát Bachus-Naur formában megadhatjuk a következőképpen.
        </para>
        <para>
            Ezt a következő logika mentén olvassuk;
            Mi az <code>utasítás</code>? <code>címkézett_utasítás</code> VAGY
            <code>összetett_utasítás</code> VAGY stb...

            Ezen logika mentén olvassuk a következő szabálysorozatot! A
            szabályokat érdemes hátulról (visszafelé) olvasni.          
        </para>
    </section>                     

    <section>
        <title>IV. Saját lexikális elemző</title>
        <para>
            Írj olyan programot, ami számolja a bemenetén megjelenő valós számokat! 
            Nem elfogadható olyan megoldás, amely maga olvassa betűnként a bemenetet, 
            a feladat lényege, hogy lexert használjunk, azaz óriások vállán álljunk és ne kispályázzunk!
        </para>
        <caution>
            <title>Tutoriált</title>
            <para>
                Ebben a feladatban tutoriált Molnár Antal.
            </para>
        </caution>
        <para>
            Megoldás forrása: 
        </para>
        <para>
            <![CDATA[ 
            %{
           
            #include <stdio.h>
            %}

            %option noyywrap

            %%
            [-+]?([0-9]*\.[0-9]+|[0-9]+) {
                                    printf("Valost talaltam: %s\n", yytext);
                            }
            .|\n	{}
            %%

            int main(void)
            {
                    yylex();
                    return 0;
            }
            ]]>
        </para>
        
        <para>
            <programlisting><![CDATA[
            {
            #include <stdio.h>
            int realnumbers = 0;
            %}
            digit	[0-9]
            %%
            {digit}*(\.{digit}+)?	{++realnumbers; 
                printf("[realnum=%s %f]", yytext, atof(yytext));}
            %%
            int
            main ()
            {
             yylex ();
             printf("The number of real numbers is %d\n", realnumbers);
             return 0;
            }
        ]]></programlisting>
        </para>
        <para>
             <emphasis role = "strong">Tanulságok, tapasztalatok, magyarázat:</emphasis>
        </para>
                <para>
			Itt a lex által ránk ruházott előnyöknél fogva egyszerűen csak
			megadjuk a definíciót, majd hagyjuk, hogy az óriások, akiknek a vállán
			állunk, dolgozzanak helyettünk.
		</para>
		<para>
			Amit fent látunk, az nem más, mint a lex definíciónk. A programnak
			megmondjuk, hogy mi értelmes, esetünkben ezt a
			<code>[-+]?([0-9]*\.[0-9]+|[0-9]+)</code>
			sor jelenti.
			Természetes nyelven olvasva ezalatt annyit értünk, hogy
			bármely szám nullától kilencig, akárhányszor előfordulása érvényes.
			A következő sorban az <code>.|\n {}</code> utasítás alapján minden
			más bemenetet ignorálunk.
		</para>
		<para>
			Kicsit részletesebben a valós szám regex definícióján:
		</para>

		<itemizedlist>
			<listitem>
				<para><code>[-+]?</code></para>
				<para>'-' vagy '+', egyszer, vagy nullaszor</para>
			</listitem>

			<listitem>
				<para><code>(</code></para>
				<para>Csoport kezdete</para>
			</listitem>

			<listitem>
				<para><code>[0-9]*</code></para>
				<para>Szám nullától kilencig, akárhányszor (ez a pont előtti rész)</para>
			</listitem>

			<listitem>
				<para><code>\.</code></para>
				<para>Szó szerint vett '.' (pont)</para>
			</listitem>

			<listitem>
				<para><code>[0-9]+</code></para>
				<para>Szám nullátok kilencig, akárhányszor</para>
			</listitem>

			<listitem>
				<para><code>|</code></para>
				<para>Logikai vagy</para>
			</listitem>

			<listitem>
				<para><code>[0-9]+</code></para>
				<para>Szám nullától kilencig, akárhányszor</para>
			</listitem>

			<listitem>
				<para><code>)</code></para>
				<para>Csoport vége</para>
			</listitem>
		</itemizedlist>

		<para>
			Látszik, hogy a reguláris kifejezésünk felépítése egyszerű. Elsőnek
			keresünk előjelet (negatív vagy pozitív) <emphasis role="strong">ÉS</emphasis>
			keressük az egészrészt valamint a törtrészt <emphasis role="strong">VAGY</emphasis>
			csak egészrészt.
		</para>

		<para>
			Ebből az egyszerűnek tűnő kódból majd a <code>lex</code> farag nekünk
			egy értelmes C kódot, amit lefordítva láthatjuk is, hogy a programunk
			működik.
		</para>

		<screen>
<![CDATA[$ lex lex.l
$ gcc lex.yy.c -o lex
$ ./lex
123ad
Valost talaltam: 123
123ad45
Valost talaltam: 123
Valost talaltam: 45
{1}{2}
Valost talaltam: 1
Valost talaltam: 2
3.1415 1.4142
Valost talaltam: 3.1415
Valost talaltam: 1.4142
...
]]>
</screen>
    </section>                     

    <section>
        <title>V. l33t.l</title>
        <para>
            Lexelj össze egy l33t ciphert!
        </para>
        <para>
            Forditas: $ lex -o l337d1c7.c l337d1c7.l 
        </para>
        <para>
            Futtatas:$ gcc l337d1c7.c -o l337d1c7 -lfl
        </para>
        <para>
            (kilépés az input vége, azaz Ctrl+D)
        </para>
        <para>
            Megoldás forrása:  
        </para>
        <para>
            <programlisting><![CDATA[
            #include <stdio.h>
            #include <stdlib.h>
            #include <time.h>
            #include <ctype.h>

            #define L337SIZE (sizeof l337d1c7 / sizeof (struct cipher))

            struct cipher {
              char c;
              char *leet[4];
            } l337d1c7 [] = {

            {'a', {"4", "4", "@", "/-\\"}},
            {'b', {"b", "8", "|3", "|}"}},
            {'c', {"c", "(", "<", "{"}},
            {'d', {"d", "|)", "|]", "|}"}},
            {'e', {"3", "3", "3", "3"}},
            {'f', {"f", "|=", "ph", "|#"}},
            {'g', {"g", "6", "[", "[+"}},
            {'h', {"h", "4", "|-|", "[-]"}},
            {'i', {"1", "1", "|", "!"}},
            {'j', {"j", "7", "_|", "_/"}},
            {'k', {"k", "|<", "1<", "|{"}},
            {'l', {"l", "1", "|", "|_"}},
            {'m', {"m", "44", "(V)", "|\\/|"}},
            {'n', {"n", "|\\|", "/\\/", "/V"}},
            {'o', {"0", "0", "()", "[]"}},
            {'p', {"p", "/o", "|D", "|o"}},
            {'q', {"q", "9", "O_", "(,)"}},
            {'r', {"r", "12", "12", "|2"}},
            {'s', {"s", "5", "$", "$"}},
            {'t', {"t", "7", "7", "'|'"}},
            {'u', {"u", "|_|", "(_)", "[_]"}},
            {'v', {"v", "\\/", "\\/", "\\/"}},
            {'w', {"w", "VV", "\\/\\/", "(/\\)"}},
            {'x', {"x", "%", ")(", ")("}},
            {'y', {"y", "", "", ""}},
            {'z', {"z", "2", "7_", ">_"}},

            {'0', {"D", "0", "D", "0"}},
            {'1', {"I", "I", "L", "L"}},
            {'2', {"Z", "Z", "Z", "e"}},
            {'3', {"E", "E", "E", "E"}},
            {'4', {"h", "h", "A", "A"}},
            {'5', {"S", "S", "S", "S"}},
            {'6', {"b", "b", "G", "G"}},
            {'7', {"T", "T", "j", "j"}},
            {'8', {"X", "X", "X", "X"}},
            {'9', {"g", "g", "j", "j"}}

          // https://simple.wikipedia.org/wiki/Leet
            };

          %}
          %%
          .	{

                    int found = 0;
                    for(int i=0; i<L337SIZE; ++i)
                    {

                      if(l337d1c7[i].c == tolower(*yytext))
                      {

                        int r = 1+(int) (100.0*rand()/(RAND_MAX+1.0));

                    if(r<91)
                          printf("%s", l337d1c7[i].leet[0]);
                    else if(r<95)
                          printf("%s", l337d1c7[i].leet[1]);
                        else if(r<98)
                          printf("%s", l337d1c7[i].leet[2]);
                        else 
                          printf("%s", l337d1c7[i].leet[3]);

                        found = 1;
                        break;
                      }

                    }

                    if(!found)
                       printf("%c", *yytext);	  

                  }
          %%
          int 
          main()
          {
            srand(time(NULL)+getpid());
            yylex();
            return 0;
          }

            ]]></programlisting>
        </para>
        <para>
             <emphasis role = "strong">Tanulságok, tapasztalatok, magyarázat:</emphasis>
        </para>
        <screen>
<![CDATA[$ lex 1337.l  && gcc lex.yy.c && ./a.out
hello, world!
h3ll0, w0rld!
what's up?
wut's up?
this is so cool!
th1s 1s s0 kewl!
what's up mate?
wut's up m8?
hey dude!
h3y d00d!
loveu
10/3u
Using a lexer is fun!
Us1ng 4 l3x3r 1s fvn!]]>
		</screen>
        <para>
			Fedezzük fel, hogy az óriások vállán állás nagyon jövedelmező.
			Ezt a programot megadtuk a következő egyszerű szabályokkal, hogy
			specifikus bemenetre mit adjon, minden mást pedig írjon le úgy, ahogy kapta.
			Ezzel a módszerrel sokkal egyszerűbb volt a feladatot megoldani,
			mint magunknak olvasni a bemenetet, és keresni benne a kicserélendő
			karakterláncokat.
		</para>

		<programlisting language="c">
<![CDATA[...
%%
"a"		{ printf("4");				}
"c"		{ printf("k");				}
"e"		{ printf("3");				}
"o"		{ printf("0");				}
"i"		{ printf("1");				}
"t"		{ printf("7");				}
"q"		{ printf("kw");				}
"A"		{ printf("/-\\");			}
"B"		{ printf("13");				}
"C"		{ printf("K");				}
"E"		{ printf("3");				}
"I"		{ printf("1");				}
"V"		{ printf("\\/");			}
"bye" 	{ printf("bai");			}
"and" 	{ printf("nd");				}
"dude" 	{ printf("d00d");			}
[...]
.|\n	{ printf("%s", yytext);		}
%%
...]]>
</programlisting>
    </section>                     


    <section>
        <title>VI. A források olvasása</title>
        <para>
            Hogyan olvasod, hogyan értelmezed természetes nyelven az alábbi kódcsipeteket? Például
            <programlisting><![CDATA[if(signal(SIGINT, jelkezelo)==SIG_IGN)
    signal(SIGINT, SIG_IGN);]]></programlisting>
            Ha a SIGINT jel kezelése figyelmen kívül volt hagyva, akkor ezen túl is legyen
            figyelmen kívül hagyva, ha nem volt figyelmen kívül hagyva, akkor a jelkezelo függvény
            kezelje. (Miután a <command>man 7 signal</command> lapon megismertem a SIGINT jelet, a
            <command>man 2 signal</command> lapon pedig a használt rendszerhívást.)
        </para>

        <caution>
            <title>Bugok</title>
            <para>
                Vigyázz, sok csipet kerülendő, mert bugokat visz a kódba! Melyek ezek és miért? 
                Ha nem megy ránézésre, elkapja valamelyiket esetleg a splint vagy a frama?
            </para>
        </caution>
            
        <orderedlist numeration="lowerroman">
            <listitem>                                    
                <programlisting><![CDATA[if(signal(SIGINT, SIG_IGN)!=SIG_IGN)
    signal(SIGINT, jelkezelo);]]></programlisting>
            </listitem>
            <listitem>                                    
                <programlisting><![CDATA[for(i=0; i<5; ++i)]]></programlisting>            
            </listitem>
            <listitem>                                    

                <programlisting><![CDATA[for(i=0; i<5; i++)]]></programlisting>            
            </listitem>
            <listitem>                                    

                <programlisting><![CDATA[for(i=0; i<5; tomb[i] = i++)]]></programlisting>            
            </listitem>
            <listitem>                                    

                <programlisting><![CDATA[for(i=0; i<n && (*d++ = *s++); ++i)]]></programlisting>            
            </listitem>
            <listitem>                                    

                <programlisting><![CDATA[printf("%d %d", f(a, ++a), f(++a, a));]]></programlisting>            
            </listitem>
            <listitem>                                    

                <programlisting><![CDATA[printf("%d %d", f(a), a);]]></programlisting>            
            </listitem>
            <listitem>                                    

                <programlisting><![CDATA[printf("%d %d", f(&a), a);]]></programlisting>            
            </listitem>
        </orderedlist>
        <para>
             <emphasis role = "strong">Tanulságok, tapasztalatok, magyarázat:</emphasis>
        </para>
              <orderedlist numeration="lowerroman">
            <listitem>
                <programlisting language="c"><![CDATA[if(signal(SIGINT, SIG_IGN)!=SIG_IGN)
signal(SIGINT, jelkezelo);]]></programlisting>
				<para>
					Ha a SIGINT jelkezelése nincs ignorálva, akkor innentől fogva
					<code>jelkezelo</code> végezze a jelkezelést.
				</para>
			</listitem>

            <listitem>
				<programlisting language="c"><![CDATA[for(i=0; i<5; ++i)]]></programlisting>
				<para>
					Végezzük el ötször, hogy... (prefix increment)
				</para>
			</listitem>

            <listitem>
				<programlisting language="c"><![CDATA[for(i=0; i<5; i++)]]></programlisting>
				<para>
					Végezzük el ötször, hogy... (postfix increment)
				</para>
			</listitem>

            <listitem>
				<programlisting language="c"><![CDATA[for(i=0; i<5; tomb[i] = i++)]]></programlisting>
				<para>
					Nem érdemes olyan kódot írni, ami valamilyen kiértékelődési
					sorrendet feltételez, ez pedig pont olyan.
                                        Nem lehet megmondani, hogy mi fog történni, mert
					az i-t már használjuk ciklusváltozónak is, valamint
					arra is, hogy a tömb elemét beállítsuk.
				</para>

	<programlisting language="c">
            <![CDATA[#include <stdio.h>

            int main(void)
            {

               int tomb[5] = { 1, 2, 3, 4, 5 };
               for (int i = 0; i < 5; tomb[i] = i++) 
                    {
                        printf("%d %d\n", i, tomb[i]);
                    }

            return 0;
            }]]>
				</programlisting>
			</listitem>

            <listitem>
				<programlisting language="c"><![CDATA[for(i=0; i<n && (*d++ = *s++); ++i)]]></programlisting>
				<para>
					A kód nehezen olvashatósága mellett kétséges a kiértékelődési
					sorrend is.
				</para>
				<para>
					Azt mondjuk, hogy legyen i=0, valamint ha i kisebb mint n,
					és a d rákövetkezője megegyezik az s rákövetkezőjével, akkor
					növeljük meg az i-t egyel.
				</para>

				<programlisting language="c">
            <![CDATA[#include <stdio.h>

            int main(void)
                {
                    int a = 4, b = 4, n = 5, *d = &a, *s = &b;

                        for (int i = 0; i < n && (*d++ = *s++); ++i) 
                            {
                                printf("%d\n", i);
                            }

                        return 0;
                }]]>
				</programlisting>

				<para>
					Ha ezt a csipetet beágyazzuk egy programba, és futtatjuk,
					akkor láthatjuk, hogy nem teljesen az történik, mint
					aimt szerettünk volna.
				</para>

			</listitem>

            <listitem>
				<programlisting language="c"><![CDATA[printf("%d %d", f(a, ++a), f(++a, a));]]></programlisting>
				<para>
					Itt az történik, hogy egy printf függvény argumentumában
					próbáljuk inkrementálni a változókat, melyre nem lehetünk
					abban biztosak, hogy milyen sorrendben fognak kiértékelődni.
					Megbizonyosodhatunk róla, hogy a program nem a kívánt eredményt
					fogja visszaadni, hogyha megpróbáljuk lefuttatni.
				</para>
				<programlisting language="c">
            <![CDATA[#include <stdio.h>

            int f(int a, int b)
            {
                return a + b;
            }

            int main()
            {
                int a = 4;

                        // 4 + 4 = 8
                        // 4 + 5 = 9 -> ehelyett 12-et kapunk
                        / 6 + 6 = 10 -> ehelyett 10-et kapunk
                printf("%d %d \n", f(a, ++a), f(++a, a));
                return 0;
            }]]>
				</programlisting>
			</listitem>

            <listitem>
				<programlisting language="c"><![CDATA[printf("%d %d", f(a), a);]]></programlisting>
				<para>
					Írassuk ki az f függvény a-ra való outputját, valamint
					magát az a-t is.
				</para>
			</listitem>

            <listitem>
				<programlisting language="c"><![CDATA[printf("%d %d", f(&a), a);]]></programlisting>
				<para>
					Itt is problémába ütközünk, hiszen az f függvény referencia
					szerint kapja meg az a változót, tehát másolás nélkül.
					Ebben az esetben az f függvény közvetlenül tudja módosítani
					az a változót, emiatt megint kétséges a kiértékelődési
					sorrend, valamit a kód is meglehetősen "rossz minőségű".
				</para>
				<programlisting language="c">
					
            <![CDATA[#include <stdio.h>

            int f(int *a)
            {
                return *a * *a;
            }
            
            int main()
            {
                int a = 2;
                            // kimenet: 4 2
                printf("%d %d \n", f(&a), a);
                return 0;
            }]]>
				</programlisting>
			</listitem>
</orderedlist>

    </section>                     

    <section>
        <title>VII. Logikus</title>
        <para>
            Hogyan olvasod természetes nyelven az alábbi Ar nyelvű formulákat?
        </para>
        <programlisting language="tex"><![CDATA[$(\forall x \exists y ((x<y)\wedge(y \text{ prím})))$ 

$(\forall x \exists y ((x<y)\wedge(y \text{ prím})\wedge(SSy \text{ prím})))$ 

$(\exists y \forall x (x \text{ prím}) \supset (x<y)) $ 

$(\exists y \forall x (y<x) \supset \neg (x \text{ prím}))$
]]></programlisting>        
        <para>
            Megoldás forrása: <link xlink:href="https://gitlab.com/nbatfai/bhax/blob/master/attention_raising/MatLog_LaTeX">https://gitlab.com/nbatfai/bhax/blob/master/attention_raising/MatLog_LaTeX</link>
        <programlisting><![CDATA[ 
            ]]></programlisting>
        
        </para>

        <para>
            Megoldás videó: <link xlink:href="https://youtu.be/ZexiPy3ZxsA">https://youtu.be/ZexiPy3ZxsA</link>, <link xlink:href="https://youtu.be/AJSXOQFF_wk">https://youtu.be/AJSXOQFF_wk</link>
        </para>

        <para>
             <emphasis role = "strong">Tanulságok, tapasztalatok, magyarázat:</emphasis>
        </para>
        <para>
            A A LaTeX egy szövegformázó rendszer, amelyet
            matematikusok használnak dokumentumok és prezentációk formázására,
            de használják nyomdákban is. Használata a tanulási fázist követően egyáltalán
            nem megerőltető, valamint több testreszabhatóságot rejt, melyek pár leütésre vannak, és az összkép még
            így is sokkal szebb, mint bármelyik más szerkesztőprogramé.
	</para>

            <figure>
		<title>LaTeX forrás lefordítva</title>
                    <mediaobject>
			<imageobject>
                            <imagedata fileref="./pictures/logical.png" width="60%" />
			</imageobject>
                    </mediaobject>
            </figure>

	<para>
            Az Ar egy elsőrendű matematikai logikai nyelv.
	</para>

	<para>
            Ezek az elsőrendű logikai kifejezések lefordítva természetes szövegre:
	</para>

            <itemizedlist>
		<listitem>
                    <para>
			A prímszámok száma végtelen.
                    </para>
		</listitem>
		<listitem>
                    <para>
			Végtelen sok ikerprím van.
                    </para>
		</listitem>
		<listitem>
                    <para>
			A prímszámok száma véges.
                    </para>
		</listitem>
		<listitem>
                    <para>
			A prímszámok száma véges.
                    </para>
		</listitem>

            </itemizedlist>
    </section>                                                                                                                                                                            
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                    
    <section>
        <title>VIII. Deklaráció</title>
            
        <para>
            Vezesd be egy programba (forduljon le) a következőket: 
        </para>

        <itemizedlist>
            <listitem>
                <para>egész</para>                        
            </listitem>
            <listitem>
                <para>egészre mutató mutató</para>                        
            </listitem>
            <listitem>
                <para>egész referenciája</para>                        
            </listitem>
            <listitem>
                <para>egészek tömbje</para>                        
            </listitem>
            <listitem>
                <para>egészek tömbjének referenciája (nem az első elemé)</para>                        
            </listitem>
            <listitem>
                <para>egészre mutató mutatók tömbje</para>                        
            </listitem>
            <listitem>
                <para>egészre mutató mutatót visszaadó függvény</para>                        
            </listitem>
            <listitem>
                <para>egészre mutató mutatót visszaadó függvényre mutató mutató</para>                        
            </listitem>
            <listitem>
                <para>egészet visszaadó és két egészet kapó függvényre mutató mutatót visszaadó, egészet kapó függvény</para>                        
            </listitem>            
            <listitem>
                <para>függvénymutató egy egészet visszaadó és két egészet kapó függvényre mutató mutatót visszaadó, egészet kapó függvényre</para>                        
            </listitem>            
        </itemizedlist>            

       <para>
            Mit vezetnek be a programba a következő nevek?
        </para>

        <itemizedlist>
            <listitem>
                <programlisting><![CDATA[int a;]]></programlisting>            
            </listitem>
            <listitem>
                <programlisting><![CDATA[int *b = &a;]]></programlisting>            
            </listitem>
            <listitem>
                <programlisting><![CDATA[int &r = a;]]></programlisting>            
            </listitem>
            <listitem>
                <programlisting><![CDATA[int c[5];]]></programlisting>            
            </listitem>
            <listitem>
                <programlisting><![CDATA[int (&tr)[5] = c;]]></programlisting>            
            </listitem>
            <listitem>
                <programlisting><![CDATA[int *d[5];]]></programlisting>            
            </listitem>
            <listitem>
                <programlisting><![CDATA[int *h ();]]></programlisting>            
            </listitem>
            <listitem>
                <programlisting><![CDATA[int *(*l) ();]]></programlisting>            
            </listitem>
            <listitem>
                <programlisting><![CDATA[int (*v (int c)) (int a, int b)]]></programlisting>            
            </listitem>            
            <listitem>
                <programlisting><![CDATA[int (*(*z) (int)) (int, int);]]></programlisting>            
            </listitem>            
        </itemizedlist>       

        <para>
             <emphasis role = "strong">Tanulságok, tapasztalatok, magyarázat:</emphasis>
        </para>
        <programlisting language="c"><![CDATA[int a;]]></programlisting>
		<para>
			egész
		</para>

		<programlisting language="c"><![CDATA[int *b = &a;]]></programlisting>
		<para>
			egészre mutató mutató
		</para>

		<programlisting language="c"><![CDATA[int &r = a;]]></programlisting>
		<para>
			egész referenciája C++ban
		</para>

		<programlisting language="c"><![CDATA[int c[5];]]></programlisting>
		<para>
			egészek tömbje
		</para>

		<programlisting language="c"><![CDATA[int (&tr)[5] = c;]]></programlisting>
		<para>
			egészek tömbjének referenciája
		</para>

		<programlisting language="c"><![CDATA[int *d[5];]]></programlisting>
		<para>
			egészek tömbjére mutató mutató
		</para>

		<programlisting language="c"><![CDATA[int *h ();]]></programlisting>
		<para>
			egészre mutató mutatót visszaadó függvény
		</para>

		<programlisting language="c"><![CDATA[int *(*l) ();]]></programlisting>
		<para>
			egészre mutatóra mutató mutatót visszaadó függvény
		</para>

		<programlisting language="c"><![CDATA[int (*v (int c)) (int a, int b)]]></programlisting>
		<para>
			két egészet kapó, egy egészre mutató mutatót visszaadó függvény
		</para>

		<programlisting language="c"><![CDATA[int (*(*z) (int)) (int, int);]]></programlisting>
		<para>
			két egészet kapó, egy egészet visszaadó függvényre mutató mutató
                </para>
    </section>                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                    
</chapter>